## 02장. 스프링을 이용한 리액티브 프로그래밍 - 기본 개념

- 관찰자 패턴
- 스프링 서버에서 보낸 이벤트를 구현한 발행 - 구독 (Publish - Subscribe) 구현
- RxJava의 역사 및 기본 개념
- Marble Diagram
- Reactive Programming을 적용한 비즈니스 사례
- Reactive Library의 현재 상황

### 리액티브를 위한 스프링 프레임워크의 초기 해법

리액티브 애플리케이션을 구축하기 위해서 스프링 프레임워크에서 여러 패턴을 지원해주었었음.

#### 관찰자(Observer) 패턴

- 객체 사이에 1:n 의존 관계를 두어 어떤 객체의 상태가 변할 때 그 객체의 의존성을 가진 다른 객체들이 그 변화를 통지받고 자동으로 갱신될 수 있게 하는 패턴
- 주체(Subject)는 관찰자(Observer)에게 상태 변경을 알림
- 각 부분이 활발히 상호 작용하면서도 응용 프로그램 사이의 **결합도를 낮출 수 있음**
- Generic : class / interface / method 등의 타입을 파라미터로 사용할 수 있게 해주는 역할

~~~java
//event를 broadcasting
public interface Subiect<T> {
	void registerObserver(Observer<T> observer); 
  void unregisterObserver(Observer<T> observer); 
  void notifyObservers(T event);
}

//subject로부터 알림을 수신
public interface Observer<T> {
  void observe(T event);
}
~~~

- 대기 시간이 상당히 긴 이벤트를 처리하는 관찰자가 많을 경우 추가적인 스레드 할당 또는 **Thread Pool**을 사용해 메시지를 병렬로 전달할 수도 있음.
  - Pool : 이미 사용할 준비가 된 자원을 메모리 위에 일정량 미리 생성해둔 자원의 집합
- 단, Thread Pool 크기 제한하지 않는 등 버그로 인해 OutOfMemoryError가 발생할 수 있음
- Thread 하나에 Java에서 약 1MB 소비 -> 단 몇천 개의 스레드만으로도 사용 가능 메모리를 모두 소모할 수 있음

#### @EventListener를 사용한 발행-구독 패턴

- Spring Framework는 이벤트 처리를 위한 **@EventListener** 애노테이션과 이벤트 발행을 위한 **ApplicationEventPublisher 클래스**를 제공한다.

- 이들은 관찰자 패턴이 아닌, **발행-구독 패턴**을 구현한다.

  <img src="./image/그림 2.3 관찰자 패턴과 발행-구독 패턴.png" alt="그림 2.3 관찰자 패턴과 발행-구독 패턴" style="zoom:40%;" />

- 구독자는 게시자가 누구인지는 신경 쓰지 않아도 됨.
- 이벤트 채널(Mesage broker, Event bus)은 수신 메시지를 구독자에게 배포하기 전에 필터링 작업을 할 수도 있음.
- @EventListener 애노테이션은 토픽 기반 라우팅과 내용 기반 라우팅 모두에 사용 가능
- 토픽 기반 라우팅 => 관심 토픽에 게시된 메시지 수신

~~~java
// 내용 기반 라우팅
// SpEL 적용
@EventListener(condition = "#orderedEvent.kakaoTalkNotification")
public void sendNotification(final OrderedEvent orderedEvent) {
    Order order = orderedEvent.getOrder();
		...
}
~~~

#### @EventListner 활용한 응용 프로그램 개발

- 방 안의 온도를 보여주는 간단한 웹 서비스
- **리액티브 디자인**에 따라 애플리케이션을 만들어보자.
- 비동기 메시지 전달을 위한 프로토콜

  - WebSocket : Server <=> Client 간 양방향이며, 한 번 연결 되면 계속 연결된 상태로 있어서 따로 업데이트가 있는지 요청을 보낼 필요가 없음. HttpHeader를 최초 접속시에만 보내고 더 이상 보내지않음
  - SSE(Server-Sent Events) : Client가 Server로 부터 데이터만 받을 수 있는 방식. 브라우저에 메시지를 업데이트하거나 연속적인 데이터 스트림을 보내는 데 사용
- Client -> EventSource라는 Javascript API 사용
- 흐름
  - 온도센서 -> 이벤트 게시자 -> REST 컨트롤러 -> USER


~~~java
final class Temperature {
  private final double value;
  // constructor & getter...
}

@Component
public class TemperatureSensor {
  private final ApplicationEventPublisher publisher;
  private final Random rnd = new Random();
  private final ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
  public TemperatureSensor(ApplicationEventPublisher publisher) {
    this.publisher = publisher;
  } 
  
  // 빈이 생성될 때 스프링 프레임워크에 의해 호출돼 온도 시나리오의 전체 시퀀스 시작
  @PostConstruct
  public void startProcessing() {
    this.executor.schedule(this::probe, 1, SECONDS);
  }
  
  private void probe() {
    double temperature = 16 + rnd.nextGaussian() * 10;
		publisher.publishEvent(new Temperature(temperature));
		// 랜덤한지연시간(0~5초)을 두고 다음 읽기 스케줄을 예약
    executor.schedule(this:probe, rnd.nextInt(5000), MILLISECONDS);
  }
}
~~~

- 비동기 HTTP 통신(역사..?)

  - 컨테이너 스레드를 통해 비동기 구현 => Callable<T>, DeferredResult<T>도 반환 가능
  - Callable<T> : 컨테이너 스레드 외부 실행 가능하나, 블로킹 호출임
  - DefferedResult<T> : 컨테이너 스레드 외부에서도 비동기 응답 생성 -> 이벤트 루프 안에서 사용 가능
  - 스프링 웹 MVC 4.2 버전부터 **ResponseBodyEmitter**를 반환할 수 있음.
  - ResponseBodyEmitter : 메시지 컨버터에 의해 개별적으로 만들어진 여러 개의 오브젝트를 전달하는 용도
  - **SseEmitter** :  ResponseBodyEmitter를 상속했으며, SSE의 프로토콜 요구 사항에 따라 하나의 수신 요청에 대해 다수의 발신 메시지를 보낼 수 있다.
  - 스프링 웹 MVC에서 **StreamingResponseBody** 인터페이스도 지원
  - StreamingResponseBody : @Controller에서 반환될 때 데이터(payload)를 비동기적으로 보낼 수 있음.

  ~~~java
  @RestController
  public class TemperatureController {
    private final Set<SseEmitter> clients = new CopyOnWriteArraySet<>();
    
    @RequestMapping(value = "/temperature-stream", method=RequestMethod.GET)
    public SseEmitter events(HttpServletRequest request) {
      SseEmitter emitter = new SseEmitter();
      clients.add(emitter);
      
      //Remove emitter from clients on error or disconnect
      emitter.onTimeout(() -> clients.remote(emitter));
      emitter.onCompletion(() -> clients.remove(emitter));
      return emitter;
    }
  }
  
  @Async
  @EventListener
  public void handleMessage(Temperature temperature) {
    List<SseEmitter> deadEmitters = new ArrayList<>();
    clients.forEach(emitter -> {
      try {
        emitter.send(temperature, MediaType.APPLICATION_JSON);
      } catch (Exception ignore) {
        deadEmitters.add(emitter);
      }
    });
    clients.removeAll(deadEmitters);
  }
  ~~~

  ~~~java
  @EnableAsync
  @SpringBootApplication
  public class Application implements AsyncConfigurer {
    public static void main(String[] args) {
      SpringApplication.run(Application.class, args);
    }
  
    @Override
    public Executor getAsyncExecutor() {
      ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); 
      executor.setCorePoolSize(2):
      executor.setMaxPoolSize(100); 
      executor.setQueueCapacity(5); 
      executor.initialize();
      return executor;
    }
  
    @Override
    public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {
      return new SimpleAsyncUncaughtExceptionHandler();
    }
  }
  ~~~

- UI 관련 코드는 생략. eventSource 사용한다 정도만 알아두자.

- 솔루션에 대한 평가

  - 고부하 및 고성능 시나리오에서는 어려움이 많음.
  - 스프링 프레임워크의 내부 메커니즘을 사용함
    - 프레임워크의 사소한 변경으로 인해 응용 프로그램의 안정성을 위협할 수 있음
    - 스프링 컨텍스트(ApplicationContext)를 로드하지 않고 비즈니스 로직을 단위 테스트하는 것은 어려움
    - 온도 이벤트를 비동기적으로 브로드캐스팅하기 위해 스레드 풀을 사용함
    - 클라이언트가 하나도 없을 때도 이벤트가 발생함

- 이러한 문제를 해결하기 위해 이 목적만을 위해 설계된 리액티브 라이브러리가 필요하다!!!

### 리액티브 프레임워크 RxJava

- RxJava 1.x 버전은 리액티브 프로그래밍을 위한 표준 라이브러리**였었음.**
- Reactive Extensions의 자바 구현체
  - 동기식 또는 비동기식 스트림과 관계없이 명령형 언어를 이용해 데이터 스트림을 조작할 수 있는 일련의 도구
- RxJava의 기본을 배워보자!!!

#### 관찰자 + 반복자 = 리액티브 스트림

- 데이터의 끝을 알리는 기능이 필요해 -> 반복자 패턴!!

  ~~~java
  public interface RxObserver<T> {
  	void onNext(T next);
  	void onComplete();
    void onError(Exception e); // RxObserver로의 오류 전파 메커니즘
  }
  // 이것이 바로 RxJava의 기본 개념인 Observer 인터페이스
  ~~~

- **Observable** 클래스 : 관찰자 패턴의 주체(Subject). 이벤트 소스 역할. 수백 가지의 스트림 변환 메서드가 있음.
- **Subscriber** 추상 클래스 : Observer 인터페이스를 구현하고 이벤트를 소비
- Observable은 0을 포함해 일정 개수의 이벤트를 보냄. 그 후 성공을 알리거나 오류를 발생시켜 실행 종료를 알림.

#### 스트림의 생산과 소비

~~~java
//여기서만 쓰이고, 이후에 사용하지는 않음. -> backpressure을 지원도 안하고, 과도한 부하를 줄 수 있음..
Observable<String> observable = Observable.create(
  new Observable.OnSubscribe<String>() {
		@Override
		public void call (Subscriber<? super String> sub) {
			sub.onNext("Hello, reactive world!"); 
      sub.onCompleted();
    }
	}
);

Subscriber<String> subscriber = new Subscriber<String>() {
  @Override
  public void onNext(String s) {
  	sout(s);
  }
  
  @Override
  public void onCompleted() {
    sout("Done!");
  }
  
  @Override
  public void onError(Throwable e) {
    serr(e);
  }
}
~~~

- 관찰자 - 구독자 협력을 제어하기 위해 Subscription 인터페이스를 사용할 수 있다.

  ~~~java
  interface Subscription {
    void unsubscribe(); //Observable에 새 이벤트를 보낼 필요가 없음을 알림.
    boolean isUnsubscribed(); // 구독자가 여전히 이벤트를 기다리고 있는지 확인.
  }
  ~~~

### 스트림 변환과 마블 다이어그램

- 스트림의 원소를 조정하거나 스트림 구조 자체를 변경 할 수 있음

- Map 연산자 : 원소에 각각 함수 적용

  <img src="/Users/seongjayong/Learning/book-spring-reactive/image/그림 2.7 map 연산자.png" alt="그림 2.7 map 연산자" style="zoom:30%;" />

- Filter 연산자 : 조건부 테스트 통과 원소만 재발행

  <img src="/Users/seongjayong/Learning/book-spring-reactive/image/그림 2.8 Filter 연산자.png" alt="그림 2.8 Filter 연산자" style="zoom:30%;" />

- Count 연산자 : 입력 스트림 개수 발행

  <img src="/Users/seongjayong/Learning/book-spring-reactive/image/그림 2.9 Count 연산자.png" alt="그림 2.9 Count 연산자" style="zoom:30%;" />

- Zip 연산자 : 두 개의 병렬 스트림 값 결합

  - 넷플릭스는 추천 비디오 목록을 스트리밍할 때, zip 연산자를 사용해 영화 설명, 영화 포스터, 영화 등급을 결합한다.

  <img src="/Users/seongjayong/Learning/book-spring-reactive/image/그림 2.10 Zip 연산자.png" alt="그림 2.10 Zip 연산자" style="zoom:30%;" />

- 어쨌든 이런 식으로 연산자를 적용해서 원하는 Output을 이끌어 낼 수 있다.

#### RxJava 사용의 전제 조건 및 이점

- 다양한 리액티브 라이브러리가 있지만, 구독자가 관찰 가능한 스트림에 가입한 후, 비동기적으로 이벤트를 생성해 프로세스를 시작한다는 핵심 개념은 동일하다.
- 프로듀서와 구독자 사이에는 Producer - Consumer 관계를 해지할 수 있는 채널이 일반적으로 존재함.
- 간단한 메모리? 검색 엔진 서비스를 구현한다고 가정하자!!

~~~java
// 단점? 클라이언트는 많든 적든 전체 결과를 동기적으로 받아야 한다.
public interface SearchEngine {
	List<URL> search(String query, int limit);
}

// 클라이언트가 결과를 화면에 표시하는 동안 서버는 다음 페이지 검색을 수행함
// 단, 다음 데이터 반환을 기다릴 때 클라이언트의 스레드가 차단됨
public interface IterableSearchEngine {
	Iterable<URL> search(String query, int limit);
} 
~~~

- 이 외에 Future를 사용할 수도 있겠지만 한번에 전체 반환 or 아무것도 반환하지 않는 방식만 가능..
- RxJava를 사용해 솔루션을 개선하자!!

~~~java
// client는 언제든지 구독 취소 가능
// 아직 모든 결과를 수신하지 못한 상태에서도 이미 도착한 부분에 대한 처리 시작 가능
public interface RxSearchEngine {
  Observable<URL> search(String query);
}
~~~

### RxJava를 이용해 애플리케이션 다시 만들기























