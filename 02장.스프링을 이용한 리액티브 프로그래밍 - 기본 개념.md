## 02장. 스프링을 이용한 리액티브 프로그래밍 - 기본 개념

- 관찰자 패턴
- 스프링 서버에서 보낸 이벤트를 구현한 발행 - 구독 (Publish - Subscribe) 구현
- RxJava의 역사 및 기본 개념
- Marble Diagram
- Reactive Programming을 적용한 비즈니스 사례
- Reactive Library의 현재 상황

### 리액티브를 위한 스프링 프레임워크의 초기 해법

리액티브 애플리케이션을 구축하기 위해서 스프링 프레임워크에서 여러 패턴을 지원해주었었음.

#### 관찰자(Observer) 패턴

- 객체 사이에 1:n 의존 관계를 두어 어떤 객체의 상태가 변할 때 그 객체의 의존성을 가진 다른 객체들이 그 변화를 통지받고 자동으로 갱신될 수 있게 하는 패턴
- 주체(Subject)는 관찰자(Observer)에게 상태 변경을 알림
- 각 부분이 활발히 상호 작용하면서도 응용 프로그램 사이의 **결합도를 낮출 수 있음**
- Generic : class / interface / method 등의 타입을 파라미터로 사용할 수 있게 해주는 역할

~~~java
//event를 broadcasting
public interface Subiect<T> {
	void registerObserver(Observer<T> observer); 
  void unregisterObserver(Observer<T> observer); 
  void notifyObservers(T event);
}

//subject로부터 알림을 수신
public interface Observer<T> {
  void observe(T event);
}
~~~

- 대기 시간이 상당히 긴 이벤트를 처리하는 관찰자가 많을 경우 추가적인 스레드 할당 또는 **Thread Pool**을 사용해 메시지를 병렬로 전달할 수도 있음.
  - Pool : 이미 사용할 준비가 된 자원을 메모리 위에 일정량 미리 생성해둔 자원의 집합
- 단, Thread Pool 크기 제한하지 않는 등 버그로 인해 OutOfMemoryError가 발생할 수 있음
- Thread 하나에 Java에서 약 1MB 소비 -> 단 몇천 개의 스레드만으로도 사용 가능 메모리를 모두 소모할 수 있음

#### @EventListener 활용한 응용 프로그램 개발

- Spring Framework는 이벤트 처리를 위한 **@EventListener** 애노테이션과 이벤트 발행을 위한 **ApplicationEventPublisher 클래스**를 제공한다.

- 이들은 관찰자 패턴이 아닌, **발행-구독 패턴**을 구현한다.

  <img src="./image/그림 2.3 관찰자 패턴과 발행-구독 패턴.png" alt="그림 2.3 관찰자 패턴과 발행-구독 패턴" style="zoom:40%;" />

- 구독자는 게시자가 누구인지는 신경 쓰지 않아도 됨.
- 이벤트 채널(Mesage broker, Event bus)은 수신 메시지를 구독자에게 배포하기 전에 필터링 작업을 할 수도 있음.

웹소켓 : Server <=> Client 간 양방향이며, 한 번 웹소켓 연결이 되면 계속 연결된 상태로 있어서 따로 업데이트가 있는지 요청을 보낼 필요가 없음. HttpHeader를 최초 접속시에만 보내고 더 이상 보내지않음

SSE : Client가 Server로 부터 데이터만 받을 수 있는 방식

SseEmitter는 ResponseBodyEmitter를 상속했으며, SSE의 프로토콜 요구 사항에 따라 하나의 수신 요청에 대해 다수의 발신 메시지를 보낼 수 있다.

