## 06장 웹플럭스 - 비동기 논블로킹 통신

- 스프링 웹플럭스에 대한 조감도
- 웹플럭스와 스프링 웹 MVC 비교
- 스프링 웹플럭스에 대한 포괄적인 디자인 개요

### 리액티브 기반 서버 기술의 핵심: 웹플럭스

- 리액티브 웹을 살펴보기 전에 웹 모듈의 디자인을 다시 정리해 보고, 모듈 내의 동작을 이해해보도록 하자.

  <img src="/Users/seongjayong/Learning/book-spring-reactive/image/그림 6.1 스프링 웹 MVC 모듈의 웹 스택 구현.png" alt="그림 6.1 스프링 웹 MVC 모듈의 웹 스택 구현" style="zoom:30%;" />

1. 사용자가 URL 입력 등으로 외부 요청이 기본 서블릿 컨테이너가 처리(ServletRequest -> ServletResponse)
2. FilterChain을 통해 ServletRequest가 필터링 단계를 거침
3. DispatcherServler : 모든 요청을 중앙 집중식으로 처리하는 프론트 컨트롤러(Spring Web + Servlet API)
4. HandlerMapping :웹 요청을 위임시키고 해당 요청을 처리할 Handler를 탐색. 비즈니스 로직을 서블릿 API에서 분리하는데 사용
5. HandlerAdapter : @Controller annotation 객체 바인딩 및 유효성 검사
6. ViewResolver : 논리 이름을 물리 이름으로 완성 시켜 줌

- 여튼 서블릿 API에 대해 직접적인 의존성을 가지는 것은 바람직하지 못함
- 서블릿 API가 버전 3.1부터 비동기 논블로킹 통신을 지원하지만, 웹MVC는 서블릿 API의 모든 기능을 지원해주지 않을 뿐만 아니라 재사용을 위한 유연성이 없기에 새로운 솔루션이 구축되는 것이 필요하였음!!

#### 리액티브 웹의 핵심

- 그렇다면, 리액티브 웹 스택은 어떻게 구성되어야할까?
- 서블릿 API에 대한 직접적인 의존성이 필요하다. -> 서블릿 API와 유사한 인터페이스를 가져야 함!!
  - javax.servlet.Servlet#service 메서드를 대체해야 함
  - 클라이언트의 요청과 서버의 응답을 서로 교환하는 서블릿 API의 방식을 개선하고 customizing해야 함
  - 새로운 인터페이스는 요청 본문 및 세션과 같은 모든 데이터에 대한 액세스를 제공해야 함 -> 그래야 데이터와 상호 작용하고 이를 처리할 수 있음

~~~java
interface ServerHttpRequest {
  ...;
  Flux<DataBuffer> getBody(); //Flux로 설정 -> reactive access
  ...;
}

interface ServerHttpResponse {
  ...;
  // 네트워크에 데이터를 보내는 비동기 프로세스인 Mono<Void>를 반환
  Mono<Void> writeWith(Publisher<? extends DataBuffer> body);
  ...;
}

//HTTP 요청, 응답 인스턴스의 컨테이너 역할, HTTP 상호작용 처리
interface ServerWebExchange {
  ...;
  ServerHttpRequest getRequest();
  ServerHttpResponse getResponse();
  ...;
  Mono<WebSession> getSession(); // WebSession에 대한 정보 포함 가능
  ...;
}
~~~

- 이러한 코드들이 기존 서블릿 API와 유사하긴 하며, 거의 동일한 방법을 제공하는 것을 목표로 하긴 하였음.
- 그렇지만 리액티브 스트림의 비동기 논블로킹 특성으로 인해 스트리밍 기반의 기능을 즉시 사용 가능하며, 콜백 지옥에서 보호해주는 식으로 설계하였음

~~~java
// HTTP 상호 작용의 핵심 진입점이며, DispatchServlet 역할
interface WebHandler {
  Mono<Void> handle(ServerWebExchange exchange); 
}

interface WebFilterChain {
  Mono<Void> filter(ServerWebExchange exchange);
}

interface WebFilter {
  Mono<Void> filter(ServerWebExchange exch, WebFilterChain chain);
}
~~~

- 이들을 통해 리액티브 웹 인프라의 필수 요소를 거의 완성하였음
- 추가적으로 필요한 것은 정의된 **인프라에 맞는 서버 엔진 적용**을 담당하는 인터페이스 + 직접적인 상호 작용을 담당할 **추상화 계층**

~~~java
public interface HttpHandler {
  Mono<Void> handle(ServerHttpRequest request, ServerHttpResponse response);
}
~~~

- **위 인터페이스를 통해 각 서버 엔진마다 주어진 ServerHttpResponse와 ServerHttpRequest를 ServerWebExchange로 결합한 후 WebFilterChain 및 WebHandler에 전달하는 HttpHandler에 대한 어댑터를 만들 수 있다**
- 즉, 스프링 웹플럭스 사용자는 특정 서버 엔진이 어떻게 작동하는지 알 필요가 없다

#### 리액티브 웹 MVC 프레임워크

- 리액티브 방식의 웹으로 대체하더라도 annotation 기반 모델은 지원해야 함
- 스프링 웹 MVC에서 사용하던 HandlerMapping과 HandlerAdpater에 대해, 리액터 타입을 사용해 리액티브 상호 작용 모델로 변경

~~~java
// Mono 타입으로 반환하여 리액티브 동작을 활성화
interface HandlerMapping {
	/* HandlerExecutionChain getHandler(HttoServletRequest request) */
	Mono<Object> getHandler(ServerWebExchange exchange);
}

// HandlerResult의 Mono를 반환 -> 직접 실행 결과를 반환
interface HandlerAdapter {
	boolean supports(Object handler);
  // ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler);
	Mono<HandlerResult> handle(ServerWebExchange exchange, Object handler);
}

~~~

- 웹 MVC에서 View는 템플릿 역할뿐만 아니라 객체 렌더링도 담당하는데, 이렇게 한 개의 클래스가 동시에 여러가지 역할을 수행하는 것은 비동기 처리 방식을 쉽게 적용할 수 없기에 뷰 검색은 해당 클래스에서 직접 처리되지 않고 HandlerAdapter에서 수행되게 하였음

<img src="/Users/seongjayong/Learning/book-spring-reactive/image/그림 6.2 다시 설계한 리액티브 웹 MVC 스택.png" alt="그림 6.2 다시 설계한 리액티브 웹 MVC 스택" style="zoom:30%;" />

1. 기본 서버 엔진으로 요청이 들어옴. 각 서버 엔진에는 요청을 처리할 수 있는 어댑터가 존재함. Jetty, Tomcat, 언더토?다 각자의 어댑터가 있음
2. HttpHandler : ServerHttpRequest, Response, 사용자 세션 및 관련 정보를 ServerWebExchange 인스턴스로 결합
3. WebFilterChain
4. DispatcherHandler -> WebHandler임
5. HandlerMapping 인스턴스 - 단순한 기능 요청 처리를 넘어서는 RouterFunctionMapping
6. RequestMappingHandlerAdapter : 리액티브 상호 작용을 처리하기 위해 리액티브 스트림 사용

#### Webflux로 구현하는 순순한 함수형 웹

- 웹플럭스는 웹 MVC와 상당 부분 미슷하지만, 많은 기능이 새롭게 추가됨.
- 함수적인 라우팅 매핑과 복잡한 요청 라우팅 로직을 작성할 수 있는 내장 API를 이용해 경량 애플리케이션을 개발하는 니즈가 있으며, 이에 Webflux도 이렇게 할 수 있다
- 함수적 접근 방식을 사용해 **RouterFunction**을 통해 복잡한 라우팅을 작성하는 방법을 살펴보자

~~~java
@SpringBootApplication
public class DemoApplication {
  @Bean
  public RouterFunction<ServerResponse> routes(OrderHandler handler) {
  	// Router Function 선언
    return
  		nest(path("/orders"),
  			nest(accept(APPLICATION_JSON), 
             route(GET("/{id}"), handler::get).andRoute(method(HttpMethod.GET), handler::list) 
        )
  			.andNest(contentType(APPLICATION_JSON), route(POST("/"), handler::create)
        )
      );
  }
}
~~~

- nest() : RouterFunction을 중첩하여 사용할 수 있도록 도와주는 메서드. 
  - 하나의 라우터가 다른 라우터 안에 둥지처럼 중첩되어 구성되는 모습을 상징하고자 이름을 이렇게 지었다네요..
  - parameter 1 : String path -> 중첩될 경로를 나타냄
  - parameter 2 : Supplier<RouterFunction<T>> routerFunctionSupplier -> 중첩될 RouterFunction을 생성하는 Supplier 객체

~~~java
class OrderHandler {
  final OrderRepository orderRepository;
	public Mono<ServerResponse> create(ServerRequest request) {
    return request
						.bodyToMono(Order.class) // 가져온 body를 Mono 객체로 변환
      			.flatMap(orderRepository::save)
						.flatMap(o -> ServerResponse.created(URI.create("/orders/" + o.id)).build()
                     //created() : URI로 201 HttpStatus 전송
		);
  }
  ...
}
~~~

- 타예제들 우선 생략...

#### WebClient: 논블로킹을 지원하는 통신 클라이언트

- WebClient는 이전 RestTemplate의 대체품이나, Flux, Mono 타입에 대한 매핑 내장 등 리액티브 방식에 적합함

  ~~~java
  webclient.create("http://localhost/api") // WebClient 인스턴스 생성
    				.get() // 원격 서버 호출
    				.uri("/users/(id)", userid)    
    				.retrieve() //내용 검색하여 조회, 다음 처리를 위해 데이터 준비										 
  					.bodyToMono(User.class)
    				.map(...)
    				.subscribe(); // 원격 호출 실행
  
  webClient.post().uri("/check")
    .body(BodyInserters.fromPublisher(
    					Mono.just(new PasswordDTO(raw, encoded)),
    					PasswordDTO.class
    ))
    .exchange() // Mono<ClientResponse> 반환
    .flatMap(response -> {
      if(response.statusCode().is2xxSuccessful()) {
        return Mono.empty();
      }
      else if(response.statusCode() == EXPECTATION_FAILED) {
        return Mono.error(new BadCredentialsException());
      }
      return Mono.error(new IllegalStateException());
    });
  ~~~

#### 리액티브 웹소켓 API

- 웹소켓 프로토콜? 비동기 메시지 전송을 위해 설계되었으나, 일부 블로킹 동작이 있음 -> 웹플럭스 모듈은 이를 개선!

##### 서버 측 웹소켓 API

- 웹플럭스는 웹소켓 연결을 처리하기 위한 핵심 인터페이스로 **WebSocketHandler**를 제공

- 핸드셰이크, 세션 속성 및 수신 데이터 스트림 등의 정보에 액세스할 수 있게 해줌

- 메시지를 보낸 사람에게 에코 메시지로 응답하는 예

  ~~~java
  class EchoWebSocketHandler implements WebSocketHandler {
  	@Override
  	public Mono<Void> handle(WebSocketSession session) { // message에 대한 처리
      return session
        .receive() // Flux 형태로 message 받아옴
        .map(WebSocketMessage::getPayloadAsText)
        .map(tm -> "Echo: " + tm)
        .map(session::textMessage) // WebSocketMessage에 메시지를 래핑
        .as(session::send); // as -> Flux를 Mono<Void>처럼 처리
    }
  }
  ~~~

- WebSocketHandler 인터페이스를 구현하지 않고, 서버 측 웹소켓 API를 설정하는 예시

  ~~~java
  @Configuration
  public class WebSocketConfiguration {
  	@Bean
  	public HandlerMapping handlerMapping() {
  		SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping();
  		mapping.setUrlMap(Collections.singletonMap( "/ws/echo", new EchoWebSocketHandler() ));
  		mapping.setOrder(-1);
  		return mapping; 
    }
    
  	@Bean
  	public HandlerAdapter handlerAdapter() {
  		return new WebSocketHandlerAdapter();
  	}
  }
  ~~~

##### 클라이언트 측 웹소켓 API

- 웹플럭스는 클라이언트 측 웹소켓 API도 지원함.

  ~~~java
  public interface WebSocketClient {
  	Mono<Void> execute( 
      URI url,
      WebSocketHandler handler
  	);
    
  	Mono<Void> execute(
  		URI url,
     	HttpHeaders headers,
      WebSocketHandler handler
     );
  }
  ~~~

- 이에 대한 구현제 예제

  ~~~java
  WebSocketClient client = new ReactorNettyWebSocketClient();
  
  client.execute(
    URI.create("http://localhost:8080/ws/echo"), 
    session -> Flux
    	.interval(Duration.ofMillis(100)) 
    	.map(String: :valuedf) 
    	.map(session: :textMessage) .as(session: :send)
  );
  ~~~

#### 웹플럭스 웹소켓과 스프링 웹소켓

- 스프링 웹소켓 : I/O와의 블로킹 동작, @MessageMapping 애노테이션 사용 허용 -> 메시징 모듈과 원활하게 통합

- 웹플럭스 웹소켓에서는 애노테이션 사용이 불가..!

  ~~~java
  @Controller
  public class GreetingController {
  	@MessageMapping("/hello") 
    @SendTo("/topic/greetings")
  	public Greeting greeting (HelloMessage message) {
      return new Greeting("Hello, " +message. getName () + "!");
    }
  }
  ~~~

#### 웹소켓 경량화를 위한 리액티브 SSE

- SSE에서는 애노테이션 기반 프로그래밍 모델을 사용하는 것과 동일한 방식으로 SSE 스트림 선언이 가능함

  ~~~java
  @RestController 
  @RequestMapping("/sse/stocks") 
  class StocksController {
  	final Map<String, StocksService> stocksServiceMap;
  	
    @GetMapping
  	public Flux<ServerSentEvent<?>> streamStocks() { // 핸들러가 이벤트 스트리밍을 활성화
  		return Flux 
        .fromIterable(stocksServiceMap.values())
  			.flatMap(StocksService::stream) 
        .<ServerSentEvent<?>>map(item ->
                                 ServerSentEvent
                                 .builder(item)
                                 .event("StockItem") 
                                 .id(item.getId())
  																.build()
         )
        .startWith(
        ServerSentEvent
        .builder() 
        .event("Stocks")
  			.data(stocksServiceMap.keySet()) 
        .build()
      );
    }
  }
  
  ~~~

  - 스프링 웹플럭스는 Flux 타입의 스트리밍 특성을 매핑하고 무한한 개수의 주식 이벤트 스트림을 클라이언트에 보냄
  - SSE는 이미 웹플럭스에 포함되어 있기 때문에 스트리밍 모델을 구성할 때 추가적인 상용구 코드가 필요하지 않음

- SSE는 바이너리 인코딩을 지원하지 않고, UTF-8만 지원하기에 메시지 크기가 작고 client - server 간 트래픽이 적어 대기 시간이 짧다면 웹소켓을 사용하자.