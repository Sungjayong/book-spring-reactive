## 07장 리액티브 방식으로 데이터베이스 사용하기

Spring Data 모듈을 사용해 리액티브 방식으로 데이터에 액세스하는 방법을 학습해보자.

선택한 DB가 리액티브 또는 비동기 드라이버를 제공하지 않더라도 **전용 스레드 풀**을 사용해 리액티브 응용 프로그램을 구축하는 방법을 알아보자.

- 최근 데이터 저장 및 처리 패턴
- 동기식 데이터 액세스의 장단점
- 스프링 데이터가 리액티브 데이터 액세스를 처리하는 방법
- 리액티브 애플리케이션에서 스프링 데이터를 사용하는 방법
- 현재 사용 가능한 리액티브 커넥터
- 블로킹 I/O에 리액티브 프로그래밍 모델을 적용하는 방법


### 최근 데이터 처리 패턴

- 마이크로서비스 패턴은 최근 응용 프로그램, 특히 **클라우드 네이티브 애플리케이션**에서 가장 중요한 아키텍처 스타일이다.
  - Cloud-native applications are a collection of small, independent, and loosely coupled services.
  - In short, cloud-native app development is a way to speed up how you build new applications, optimize existing ones, and connect them all. - redhat -
- 마이크로서비스의 관점에서 데이터 저장에 대한 기본 개념, 사용 가능한 전략, 구현 방법 및 데이터 영속화와 관련된 몇 가지 권장 사항을 살펴보자.

#### 도메인 주도 설계

- 에릭 에반스가 쓴 도메인 주도 설계는 모든 소프트웨어 엔지니어의 책장 가장 잘 보이는 자리에 꽂아둬야 한다.

- DDD(Domain-driven design)는 공통 어휘(즉, 컨텍스트, 도메인, 모델 및 유비쿼터스 언어)를 설정하고 모델의 무결성을 유지하기 위한 일련의 원칙을 공식화한다.

- DDD의 관점에서 정의한 각각의 바운디드 컨텍스트(bounded context)가 하나의 마이크로서비스로 매핑된다.

  <img src="/Users/seongjayong/Learning/book-spring-reactive/image/그림 7.1 바운디드 컨텍스트.png" alt="그림 7.1 바운디드 컨텍스트" style="zoom:30%;" /> 

- DDD는 비즈니스 핵심 도메인에 집중하며, 그 중에서도 특히 도메인 모델을 표현, 생성, 검색하는 수단에 중점을 두고 있음.
- 엔티티, 데이터 전달 객체(VO, value object), 애그리게이트(aggregate), repository
- DDD를 염두에 두고 애플리케이션을 구현한다면 앞에서 언급한 객체는 서비스의 영속 계층과 매핑해야 한다.

#### 마이크로서비스 시대의 데이터 저장소

- 마이크로서비스 아키텍처가 도입됨에 따라 영속 계층에 생긴 가장 큰 변화라고 한다면 서비스 간에 데이터 저장소를 공유하지 않게 된 것이다.

  - 즉, 논리적으로 분할된 각각의 서비스가 DB를 소유하고 관리하는 경우, 서비스 API 호출을 제외한 방식으로는 다른 서비스의 데이터에 액세스할 수 없는 것이 이상적

- 물리적으로 보면 스토리지 분리는 몇 가지 방식으로 구현할 수 있음

  1. 하나의 DB 서버를 두고 각각의 서비스에 대해 별도의 스키마를 할당하는 것

  <img src="/Users/seongjayong/Learning/book-spring-reactive/image/그림 7.3 스키마로 서비스 분리.png" alt="그림 7.3 스키마로 서비스 분리" style="zoom:40%;" />

  - 구현이 쉽고 서버 리소스를 적게 필요로 하며, 실제 운영 환경에서 많은 관리 작업을 필요로 하지 않으므로 응용 프로그램 개발 초기 단계에서 좋음.

  - 데이터 분리는 데이터베이스 액세스 제어 규칙을 사용해 강제할 수 있다?

  - 개발자가 하나 이상의 쿼리를 작성해 둘 이상의 서비스에 속한 데이터를 검색하거나 변경할 수 있기에, 서비스를 손상시킬 수도 있음. ➡️ 보안 위협

  2. 하나의 데이터베이스 서버를 공유하지만, 다른 액세스 권한을 가지고 별도의 데이터베이스를 보유하는 방식

     <img src="/Users/seongjayong/Learning/book-spring-reactive/image/그림 7.4 데이터베이스로 서비스 분리.png" alt="그림 7.4 데이터베이스로 서비스 분리" style="zoom:40%;" />

     - 단일 쿼리를 통해 다른 서비스의 데이터에 액세스하는 것이 훨씬 어렵기 때문에 데이터 분리 관점에서는 더 나은 결과를 낼 수 있음
     - 백업 작업을 약간 복잡하게 만듬.

  3. 서비스마다 별도의 데이터베이스 서버 생성

     <img src="/Users/seongjayong/Learning/book-spring-reactive/image/그림 7.5 데이터베이스 서버로 서비스 분리.png" alt="그림 7.5 데이터베이스 서버로 서비스 분리" style="zoom:40%;" />

     - 각각의 데이터베이스 서버를 세부적으로 설정해 서비스가 가진 고유한 요구 사항을 충족시킬 수 있음
     - 특정 서비스의 확장이 필요한 경우 해당 데이터베이스 서버만 쉽게 수직 또는 수평으로 확장할 수 있음

  4. 혼합도 가능

     - 다른 종류의 데이터베이스 서버를 동시에 사용하는 것도 가능하며, 다른 종류의 데이터베이스(SQL, NoSQL)을 함께 사용해 최상의 결과를 얻을 수도 있음
     - 이러한 접근법을 **다중 저장소 영속화(polyglot persistence)**라고 한다.

#### 다중 저장소 영속화

- 다중 언어 프로그래밍 ➡️ 비즈니스 또는 기술적인 맥락에서 소프트웨어 시스템을 만들기 위한 가장 적합한 언어를 사용해 최고의 효과를 얻기 위해 여러 가지 언어로 작성할 수 있다는 생각을 표현한 것
- 데이터 영속성 분야에서도 이와 유사한 생각의 변화가 있었음
  - 예로, 분산 웹 애플리케이션을 위한 HTTP 세션을 저장하는 것과 소셜 네트워크에 친구 그래프를 저장하는 것은 서로의 특성이 다르기 때문에 다른 DB를 필요한다.
- 대부분의 RDBMS는 동일한 ACID 원칙을 토대로 구축됐으며 스토리지와 통신하기 위해 거의 유사한 SQL 언어를 제공함.
- 일반적으로 RDBMS는 광범위한 응용 프로그램엔 적합하지만, 그래프 저장, 메모리 내 저장소 및 분산 저장소 등에 대해 최상의 성능 및 관리 기능을 제공하는 경우는 거의 없음.
- 반면, 최근에 등장한 NoSQL 데이터베이스는 광범위한 기본 원칙을 가지고 있어 범용 데이터 저장소로 효율적으로 사용할 수는 없음 

<img src="/Users/seongjayong/Learning/book-spring-reactive/image/그림 7.7 각각의 서비스에 가장 적합한 영속화 기술을 사용하는 설계.png" alt="그림 7.7 각각의 서비스에 가장 적합한 영속화 기술을 사용하는 설계" style="zoom:50%;" />

- 다중 언어 영속성은 복잡성으로 인해 추가 비용이 발생함
  - 새로운 스토리지 매커니즘마다 새로운 API, 데이터 패러다임, 라이브러리, 개발과 생산에서 다루기 위한 새로운 일련의 표준을 배워야 함.
  - NoSQL을 잘못 사용했다가는 서비스를 처음부터 다시 설계해야 할 수도 있음
- 스프링 프레임워크는 **스프링 데이터**라는 데이터 영속성을 위한 하위 프로젝트를 가지고 있음.
- 이에 대해 알아보자..!

#### 서비스로서의 데이터베이스

- 마이크로서비스 아키텍처에서는 모든 서비스가 상태에 의존적이지 않으며, 모든 상태 정보는 데이터 지속성을 관리하는 방법을 알고 있는 특수 서비스?에 저장된다. ➡️ DB나 Cache를 말하는 듯?
- 클라우드 환경에서는 서비스가 상태를 저장하지 않음으로써 효율적으로 확장할 수 있고 높은 가용성을 가질 수 있다
- 클라우드용으로 설계되지 않은 데이터베이스 서버를 효율적으로 관리하고 조정하는 것은 꽤나 어려운 일
- 대부분 클라우드 제공 업체는 데이터베이스를 서비스(DBaaS)로 제공해 이러한 문제를 해결
  - 이러한 스토리지 솔루션은 일반 데이터베이스(MySQL, PostgreSQL 및 Redis)를 약간 수정해서 제공하거나 애초에 클라우드용으로 설계됨(AWS Redshift, 구글 BigTable 및 마이크로소프트 CosmosDB)
- 일반적으로 클라우드 저장소나 DB에서 사용하는 알고리즘은 다음과 같은 방식으로 동작함.
  1. 클라이언트가 데이터베이스 또는 파일 저장 영역에 대한 액세스 요청
  2. 클라우드 공급자는 데이터 영역에 접근할 수 있는 API 또는 서버 자원에 대한 권한을 부여, 이 때 클라이언트는 제공되는 API의 세부 구현에 대해서는 신경 쓰지 않음
  3. 클라이언트는 액세스 자격 증명을 제공하는 스토리지 API 또는 데이터베이스 드라이버를 사용
  4. 클라우드 공급자는 클라이언트의 지불 방법, 저장된 데이터 크기, 쿼리 빈도, 동시 접속 또는 기타 특성에 따라 클라이언트에게 요금 부과
- 클라우드 공급 업체는 클라이언트 데이터를 저장하고 처리하는 가장 효율적인 방법을 구현해 기반 인프라에 대한 지출 최소화
- 클라이언트는 핵심 비즈니스 목표 달성에 집중하며 데이터베이스 서버 복제 또는 백업을 구성하는 데 들어가는 시간 낭비 최소화
- 잘 알려진 클라우드 기반 데이터 저장소 및 DB 서비스는 AWS S3, AWS DynamoDB, Heroic PostgreSQL 등등이 있음..

#### 마이크로서비스 사이의 데이터 공유

- 실제 비즈니스 시스템에서는 클라이언트 요청을 처리하기 위해 두 개 이상의 서비스가 소유한 데이터를 쿼리해야 하는 경우가 있음
- 단일 조인 쿼리는 마이크로서비스에서는 금지됨.
- **다중 서비스 요청**을 처리하려면 주문 및 결제 서비스를 모두 쿼리하고 필요한 데이터를 변환해 집계 결과를 클라이언트에 반환하는 어댑터 서비스를 구현해야 함
- 또한 두 서비스 사이에 데이터 요청이 많거나 의존성이 강한 경우에는 DDD를 손상시키지 않는 경우에 한해서 하나의 서비스로 병합하는 게 나음

<img src="/Users/seongjayong/Learning/book-spring-reactive/image/그림 7.8 주문 서비스와 결제 서비스의 데이터를 집계하는 어댑터 서비스.png" alt="그림 7.8 주문 서비스와 결제 서비스의 데이터를 집계하는 어댑터 서비스" style="zoom:50%;" />

- 데이터를 조회하는 것은 매우 간단하지만, 한 번에 몇 가지 서비스를 동시에 업데이트하는 것은 훨씬 어려움.
  - 고객이 주문을 요청했지만, 재고가 충분한지와 결제 정보가 유효한지를 확인하는 것만 가능하다고 가정하자.
  - 모든 서비스에는 자체 DB가 있으므로 워크플로 내에서 두 개 이상의 마이크로서비스와 데이터베이스가 비즈니스 트랜잭션에 참여함.
  - 가장 많이 사용되는 두 가지 방법은 **분산 트랜잭션**과 **이벤트 기반 아키텍처**이다.

##### 분산 트랜잭션

- 네트워크가 분리된 두 개 이상의 컴퓨터 시스템에 저장된 데이터를 업데이트하는 트랜잭션.
  - 다시 말해, 어떤 행동이 일어났는지에 대해 여러 개의 서비스가 동시에 동의한다는 뜻.
  - 실제로 대부분 데이터베이스 시스템은 강력하고 엄격한 2단계 록(two-phase locking)을 사용해 글로벌 직렬성(순차성?)을 보장
- 분산 트랜잭션은 데이터 저장소를 원자적으로 업데이트하기 위해 서비스에서 자주 사용됨
- 이 방식은 또한 장애 발생 시 복구에도 유용함
- 하지만, 분산 트랜잭션은 마이크로서비스에는 권장되지 않음.
  - 2단계 커밋을 지원하는 API가 필요하지만, 구현이 어려움.
  - 분산 트랜잭션 사용 시 **강하게 결합**되어야 하기에, 이는 마이크로서비스 아키텍처에서 권장하지 않는 방식임.
  - 확장이 어려움

##### 이벤트 기반 아키텍처

- 마이크로서비스에서는 그래서 이벤트 기반 아키텍처를 사용합니다

- 시스템의 상태를 변경하는 CASE

  - 첫 번째 서비스가 자체 DB에서 데이터를 변경하고 동일한 내부 트랜잭션에서 이벤트를 **메시지 브로커**에 전달(서비스 경계를 넘지 않음!!!)
  - 두 번째 서비스는 이벤트 메시지를 수신하고 이에 따라 저장 데이터 변경
  - 때에 따라 다시 이벤트를 송신할 수도 있음(**서비스는 동시에 블로킹되지 않으며** 상호 의존성이 없음)
  - 유일한 결합 지점은 **교환하는 메시지**
  - 첫 번째 서비스가 작동하는 시점에 두 번째 서비스가 실행 중이 아니라도 요청에 대한 처리를 계속 할 수 있음 ➡️ 복원력이 높음 ➡️ Reactive

  

- 이전에도 말했지만, 두 서비스가 **수다스러울 정도**로 많은 정보를 교환한다면 서비스 병합을 고려하자.

- 또한 이벤트를 사용해 몇 가지 서비스에 대해 동시에 업데이트를 수행하는 어댑터 서비스를 구현할 수도 있다

##### 궁극적 일관성

- 소프트웨어 시스템에서 분산 트랜잭션을 수행하는 방식을 분석해보자..
- 분산 트랜잭션의 사용은 시스템의 모든 부분에서 항상 **일관성**을 보장할 것이라 확신하지만, **불확실성의 제거**는 매우 제한적인 요구이다?
- DDD 저자 반 버논에 따르면, 불확실성을 도메인 모델에 포함시킬 것을 제안한다. 
  - 책에 따르면 시스템에는 어떤 방식으로든 일관성 없는 상태가 발생할 수 있으며 불확실성이 계속 발생하고 이로 인해 문제가 발생하더라도 이를 비즈니스 워크플로의 일부로 포함시키는 것이 좋다는 것.
- 예로, [결제 정보 확인 중]이라는 새로운 상태를 도입해 결제 정보 확인 없이 주문을 생성할 수도 있다.
  - 이 새로운 상태는 불확실한 상황(결제 정보의 비유효)을 한정된 시간 동안(결제 정보가 확인될 때까지) 유지되는 별도의 비즈니스 이벤트로 다룬다.
  - 이러한 접근 방식을 사용하면 **시스템에서 항상 일관성을 유지할 필요가 없음**
  - 대신 시스템에서 각 비즈니스 트랜잭션의 상태를 관찰하기 위한 일관적인 뷰가 있는지 확인해야 함
  - 이러한 미래의 일관성을 **궁극적 일관성(eventual consistency)**라고 한다.
    - 즉 지금은 두 서버가 일관적이지 않지만, 미래에는 동기화가 되어 일관성을 가지게 될 거야 그러니 일관성에 너무 집중하지 말자라는 말이 아닐까?
  - 대개 궁극적 일관성을 보장한다 ➡️ 운영을 성공적으로 수행할 수 있는 안정적인 시스템으로 볼 수 있음! 

<img src="/Users/seongjayong/Learning/book-spring-reactive/image/그림 7.9 메시지를 이용해 각각의 데이터베이스를 업데이트하는 주문과 결제 서비스.png" alt="그림 7.9 메시지를 이용해 각각의 데이터베이스를 업데이트하는 주문과 결제 서비스" style="zoom:50%;" />

##### SAGA 패턴 ⭐️

- 특히 마이크로서비스 분야에서 분산 트랜잭션에 가장 널리 사용되는 패턴 중 하나가 **SAGA 패턴**이다.
- saga는 소수의 작은 트랜잭션으로 구성되며, 각 트랜잭션은 하나의 마이크로서비스에 국한된다.
- 외부 요청이 saga를 시작하고, saga가 첫 번째 작은 트랜잭션을 시작 ➡️ 성공할 경우, 두 번째 트랜잭션 시작 ➡️ 트랜잭션이 중간에 성공하지 못하면 이전 트랜잭션에 대한 보상 기동
- 이를 구현하는 패턴에는 코레오그래피(event-based choreography)와 오케스트레이션(orchestration via a coordinator service)의 두 가지가 있다.

##### 이벤트 소싱

- 마이크로서비스 응용 프로그램의 이벤트 플로를 처리하기 위해 이벤트 소싱 패턴을 사용할 수 있다
- 이벤트 소싱은 각 비즈니스 엔티티의 상태 변화 순서를 저장.
  - 예를 들어, 은행 계좌는 초기 금액과 예금/인출 순서로 나타낼 수 있다
  - 이 정보를 사용하면 업데이트 이벤트를 순차적으로 복기해 현재 계정 상태를 계산할 수 있을 뿐만 아니라 엔티티 변경 사항에 대한 신뢰할 수 있는 감사 로그를 제공할 수 있다.
  - 현재 상태를 계산하는 데 필요한 시간을 최적화하기 위해 응용 프로그램은 스냅 샷을 주기적으로 작성하고 저장할 수 있음
  - 저장소 크기를 줄이기 위해 선택한 스냅샷 이전의 이벤트를 삭제할 수도 있음
- 이런 단순함에도 불구하고 개발자들에게 익숙하지 않다는 점과 일반적인 프로그래밍 방식과의 차이, 학습 시간이 길다는 이유로 이벤트 소싱은 자주 사용되지 않음.
- 또한 상태를 지속적으로 재계산해야 하기 때문에 이베트 소싱을 사용하면 특히 쿼리가 복잡할 때 효율적인 쿼리를 수행할 수 없음
- 이 경우 CQRS(명령 및 쿼리 책임 분리) 가 도움이 된다.

##### 명령 및 쿼리 책임 분리(CQRS)

- 이벤트 소싱과 함께 사용되며 두 부분으로 구성
  - Write 파트 : 상태 변경 명령을 수신해 이벤트 저장소에 저장
  - Read 파트 : 상태를 변경하지 않고 요청된 쿼리의 결과를 반환.??? 별개의 쿼리에 대한 상태 표현은 뷰로 저장되며, 갱신 이벤트가 명령으로 수신된 후에 비동기식으로 다시 계산됨

<img src="/Users/seongjayong/Learning/book-spring-reactive/image/그림 7.10 CQRS 구현.png" alt="그림 7.10 CQRS 구현" style="zoom:40%;" />

- CQRS 패턴은 소프트웨어 시스템이 대량의 데이터를 스트리밍 방식으로 처리할 수 있도록 해주고, 동시에 현재 시스템 상태와 관련된 다양한 쿼리에 신속하게 응답할 수 있다.

##### 충돌 없는 복제 데이터 타입(CRDT)

- 트랜잭션은 확장성이 좋지 않으며 응용 프로그램이 늘어남에 따라 하나의 마이크로서비스 영역 내에서 글로벌 상태를 일관되게 유지하는 것은 점점 더 어려워진다.
- 따라서 성능 및 시스템 확장성을 위해 글로벌 록이나 트랜잭션 **일관성 없이** **여러 서비스 인스턴스에서 동시에 데이터를 업데이트**하는 경우가 발생할 수 있음
- 이러한 접근 방식을 **낙관적 복제(optimistic replication)**라고 하며, 나중에 발생할 불일치를 감수하면서 데이터 복제본을 병행해서 사용할 수 있음.
- 병합 프로세스가 항상 성공할 수 있도록 하는 수학적 속성을 가진 데이터 구조가 있는데, 이를 **충돌 없는 복제 데이터 타입(CRDT)**라고 한다.
- Cosmos DB, Redis 등 충돌 없는 복제 데이터베이스(CRDB)의 형태로 CRDT를 기본적으로 지원한다.

##### 데이터 저장소로서의 메시징 시스템

- 메시지를 위한 영속성 스토리지를 가진 메시지 브로커가 개별 마이크로서비스를 위한 전용 데이터베이스에 대한 필요성을 감소시킬 수 있다.
- 실제로 모든 엔티티에 대한 업데이트 이벤트(엔티티 스냅샷 포함)가 충분한 시간 동안 메시지 브로커에 저장되고 언제든지 다시 읽을 수 있다면 이 이벤트만으로도 시스템의 전체 상태를 정의할 수 있다.
- 서비스는 새로운 업데이트 명령을 처리하고 쿼리를 읽고 때때로 브로커에 엔티티 스냅샷을 생성하고 보내는 것만으로도 동작할 수 있다..!
- 아파치 카프카에 신뢰할 수 있는 영속성 계층이 있어서 시스템의 주 데이터 저장소로 사용할 수 있을 뿐만 아니라 시스템 내의 유일한 데이터 저장소로도 활용할 수 있다. 

























