## 07장 리액티브 방식으로 데이터베이스 사용하기

Spring Data 모듈을 사용해 리액티브 방식으로 데이터에 액세스하는 방법을 학습해보자.

선택한 DB가 리액티브 또는 비동기 드라이버를 제공하지 않더라도 **전용 스레드 풀**을 사용해 리액티브 응용 프로그램을 구축하는 방법을 알아보자.

- 최근 데이터 저장 및 처리 패턴
- 동기식 데이터 액세스의 장단점
- 스프링 데이터가 리액티브 데이터 액세스를 처리하는 방법
- 리액티브 애플리케이션에서 스프링 데이터를 사용하는 방법
- 현재 사용 가능한 리액티브 커넥터
- 블로킹 I/O에 리액티브 프로그래밍 모델을 적용하는 방법


### 최근 데이터 처리 패턴

- 마이크로서비스 패턴은 최근 응용 프로그램, 특히 **클라우드 네이티브 애플리케이션**에서 가장 중요한 아키텍처 스타일이다.
  - Cloud-native applications are a collection of small, independent, and loosely coupled services.
  - In short, cloud-native app development is a way to speed up how you build new applications, optimize existing ones, and connect them all. - redhat -
- 마이크로서비스의 관점에서 데이터 저장에 대한 기본 개념, 사용 가능한 전략, 구현 방법 및 데이터 영속화와 관련된 몇 가지 권장 사항을 살펴보자.

#### 도메인 주도 설계

- 에릭 에반스가 쓴 도메인 주도 설계는 모든 소프트웨어 엔지니어의 책장 가장 잘 보이는 자리에 꽂아둬야 한다.

- DDD(Domain-driven design)는 공통 어휘(즉, 컨텍스트, 도메인, 모델 및 유비쿼터스 언어)를 설정하고 모델의 무결성을 유지하기 위한 일련의 원칙을 공식화한다.

- DDD의 관점에서 정의한 각각의 바운디드 컨텍스트(bounded context)가 하나의 마이크로서비스로 매핑된다.

  <img src="/Users/seongjayong/Learning/book-spring-reactive/image/그림 7.1 바운디드 컨텍스트.png" alt="그림 7.1 바운디드 컨텍스트" style="zoom:30%;" /> 

- DDD는 비즈니스 핵심 도메인에 집중하며, 그 중에서도 특히 도메인 모델을 표현, 생성, 검색하는 수단에 중점을 두고 있음.
- 엔티티, 데이터 전달 객체(VO, value object), 애그리게이트(aggregate), repository
- DDD를 염두에 두고 애플리케이션을 구현한다면 앞에서 언급한 객체는 서비스의 영속 계층과 매핑해야 한다.

#### 마이크로서비스 시대의 데이터 저장소

- 마이크로서비스 아키텍처가 도입됨에 따라 영속 계층에 생긴 가장 큰 변화라고 한다면 서비스 간에 데이터 저장소를 공유하지 않게 된 것이다.

  - 즉, 논리적으로 분할된 각각의 서비스가 DB를 소유하고 관리하는 경우, 서비스 API 호출을 제외한 방식으로는 다른 서비스의 데이터에 액세스할 수 없는 것이 이상적

- 물리적으로 보면 스토리지 분리는 몇 가지 방식으로 구현할 수 있음

  1. 하나의 DB 서버를 두고 각각의 서비스에 대해 별도의 스키마를 할당하는 것

  <img src="/Users/seongjayong/Learning/book-spring-reactive/image/그림 7.3 스키마로 서비스 분리.png" alt="그림 7.3 스키마로 서비스 분리" style="zoom:40%;" />

  - 구현이 쉽고 서버 리소스를 적게 필요로 하며, 실제 운영 환경에서 많은 관리 작업을 필요로 하지 않으므로 응용 프로그램 개발 초기 단계에서 좋음.

  - 데이터 분리는 데이터베이스 액세스 제어 규칙을 사용해 강제할 수 있다?

  - 개발자가 하나 이상의 쿼리를 작성해 둘 이상의 서비스에 속한 데이터를 검색하거나 변경할 수 있기에, 서비스를 손상시킬 수도 있음. ➡️ 보안 위협

  2. 하나의 데이터베이스 서버를 공유하지만, 다른 액세스 권한을 가지고 별도의 데이터베이스를 보유하는 방식

     <img src="/Users/seongjayong/Learning/book-spring-reactive/image/그림 7.4 데이터베이스로 서비스 분리.png" alt="그림 7.4 데이터베이스로 서비스 분리" style="zoom:40%;" />

     - 단일 쿼리를 통해 다른 서비스의 데이터에 액세스하는 것이 훨씬 어렵기 때문에 데이터 분리 관점에서는 더 나은 결과를 낼 수 있음
     - 백업 작업을 약간 복잡하게 만듬.

  3. 서비스마다 별도의 데이터베이스 서버 생성

     <img src="/Users/seongjayong/Learning/book-spring-reactive/image/그림 7.5 데이터베이스 서버로 서비스 분리.png" alt="그림 7.5 데이터베이스 서버로 서비스 분리" style="zoom:40%;" />

     - 각각의 데이터베이스 서버를 세부적으로 설정해 서비스가 가진 고유한 요구 사항을 충족시킬 수 있음
     - 특정 서비스의 확장이 필요한 경우 해당 데이터베이스 서버만 쉽게 수직 또는 수평으로 확장할 수 있음

  4. 혼합도 가능

     - 다른 종류의 데이터베이스 서버를 동시에 사용하는 것도 가능하며, 다른 종류의 데이터베이스(SQL, NoSQL)을 함께 사용해 최상의 결과를 얻을 수도 있음
     - 이러한 접근법을 **다중 저장소 영속화(polyglot persistence)**라고 한다.

#### 다중 저장소 영속화

- 다중 언어 프로그래밍 ➡️ 비즈니스 또는 기술적인 맥락에서 소프트웨어 시스템을 만들기 위한 가장 적합한 언어를 사용해 최고의 효과를 얻기 위해 여러 가지 언어로 작성할 수 있다는 생각을 표현한 것
- 데이터 영속성 분야에서도 이와 유사한 생각의 변화가 있었음
  - 예로, 분산 웹 애플리케이션을 위한 HTTP 세션을 저장하는 것과 소셜 네트워크에 친구 그래프를 저장하는 것은 서로의 특성이 다르기 때문에 다른 DB를 필요한다.
- 대부분의 RDBMS는 동일한 ACID 원칙을 토대로 구축됐으며 스토리지와 통신하기 위해 거의 유사한 SQL 언어를 제공함.
- 일반적으로 RDBMS는 광범위한 응용 프로그램엔 적합하지만, 그래프 저장, 메모리 내 저장소 및 분산 저장소 등에 대해 최상의 성능 및 관리 기능을 제공하는 경우는 거의 없음.
- 반면, 최근에 등장한 NoSQL 데이터베이스는 광범위한 기본 원칙을 가지고 있어 범용 데이터 저장소로 효율적으로 사용할 수는 없음 

<img src="/Users/seongjayong/Learning/book-spring-reactive/image/그림 7.7 각각의 서비스에 가장 적합한 영속화 기술을 사용하는 설계.png" alt="그림 7.7 각각의 서비스에 가장 적합한 영속화 기술을 사용하는 설계" style="zoom:50%;" />

- 다중 언어 영속성은 복잡성으로 인해 추가 비용이 발생함
  - 새로운 스토리지 매커니즘마다 새로운 API, 데이터 패러다임, 라이브러리, 개발과 생산에서 다루기 위한 새로운 일련의 표준을 배워야 함.
  - NoSQL을 잘못 사용했다가는 서비스를 처음부터 다시 설계해야 할 수도 있음
- 스프링 프레임워크는 **스프링 데이터**라는 데이터 영속성을 위한 하위 프로젝트를 가지고 있음.
- 이에 대해 알아보자..!

#### 서비스로서의 데이터베이스

- 마이크로서비스 아키텍처에서는 모든 서비스가 상태에 의존적이지 않으며, 모든 상태 정보는 데이터 지속성을 관리하는 방법을 알고 있는 특수 서비스?에 저장된다. ➡️ DB나 Cache를 말하는 듯?
- 클라우드 환경에서는 서비스가 상태를 저장하지 않음으로써 효율적으로 확장할 수 있고 높은 가용성을 가질 수 있다
- 클라우드용으로 설계되지 않은 데이터베이스 서버를 효율적으로 관리하고 조정하는 것은 꽤나 어려운 일
- 대부분 클라우드 제공 업체는 데이터베이스를 서비스(DBaaS)로 제공해 이러한 문제를 해결
  - 이러한 스토리지 솔루션은 일반 데이터베이스(MySQL, PostgreSQL 및 Redis)를 약간 수정해서 제공하거나 애초에 클라우드용으로 설계됨(AWS Redshift, 구글 BigTable 및 마이크로소프트 CosmosDB)
- 일반적으로 클라우드 저장소나 DB에서 사용하는 알고리즘은 다음과 같은 방식으로 동작함.
  1. 클라이언트가 데이터베이스 또는 파일 저장 영역에 대한 액세스 요청
  2. 클라우드 공급자는 데이터 영역에 접근할 수 있는 API 또는 서버 자원에 대한 권한을 부여, 이 때 클라이언트는 제공되는 API의 세부 구현에 대해서는 신경 쓰지 않음
  3. 클라이언트는 액세스 자격 증명을 제공하는 스토리지 API 또는 데이터베이스 드라이버를 사용
  4. 클라우드 공급자는 클라이언트의 지불 방법, 저장된 데이터 크기, 쿼리 빈도, 동시 접속 또는 기타 특성에 따라 클라이언트에게 요금 부과
- 클라우드 공급 업체는 클라이언트 데이터를 저장하고 처리하는 가장 효율적인 방법을 구현해 기반 인프라에 대한 지출 최소화
- 클라이언트는 핵심 비즈니스 목표 달성에 집중하며 데이터베이스 서버 복제 또는 백업을 구성하는 데 들어가는 시간 낭비 최소화
- 잘 알려진 클라우드 기반 데이터 저장소 및 DB 서비스는 AWS S3, AWS DynamoDB, Heroic PostgreSQL 등등이 있음..

#### 마이크로서비스 사이의 데이터 공유

- 실제 비즈니스 시스템에서는 클라이언트 요청을 처리하기 위해 두 개 이상의 서비스가 소유한 데이터를 쿼리해야 하는 경우가 있음
- 단일 조인 쿼리는 마이크로서비스에서는 금지됨.
- **다중 서비스 요청**을 처리하려면 주문 및 결제 서비스를 모두 쿼리하고 필요한 데이터를 변환해 집계 결과를 클라이언트에 반환하는 어댑터 서비스를 구현해야 함
- 또한 두 서비스 사이에 데이터 요청이 많거나 의존성이 강한 경우에는 DDD를 손상시키지 않는 경우에 한해서 하나의 서비스로 병합하는 게 나음

<img src="/Users/seongjayong/Learning/book-spring-reactive/image/그림 7.8 주문 서비스와 결제 서비스의 데이터를 집계하는 어댑터 서비스.png" alt="그림 7.8 주문 서비스와 결제 서비스의 데이터를 집계하는 어댑터 서비스" style="zoom:50%;" />

- 데이터를 조회하는 것은 매우 간단하지만, 한 번에 몇 가지 서비스를 동시에 업데이트하는 것은 훨씬 어려움.
  - 고객이 주문을 요청했지만, 재고가 충분한지와 결제 정보가 유효한지를 확인하는 것만 가능하다고 가정하자.
  - 모든 서비스에는 자체 DB가 있으므로 워크플로 내에서 두 개 이상의 마이크로서비스와 데이터베이스가 비즈니스 트랜잭션에 참여함.
  - 가장 많이 사용되는 두 가지 방법은 **분산 트랜잭션**과 **이벤트 기반 아키텍처**이다.

##### 분산 트랜잭션

- 네트워크가 분리된 두 개 이상의 컴퓨터 시스템에 저장된 데이터를 업데이트하는 트랜잭션.
  - 다시 말해, 어떤 행동이 일어났는지에 대해 여러 개의 서비스가 동시에 동의한다는 뜻.
  - 실제로 대부분 데이터베이스 시스템은 강력하고 엄격한 2단계 록(two-phase locking)을 사용해 글로벌 직렬성(순차성?)을 보장
- 분산 트랜잭션은 데이터 저장소를 원자적으로 업데이트하기 위해 서비스에서 자주 사용됨
- 이 방식은 또한 장애 발생 시 복구에도 유용함
- 하지만, 분산 트랜잭션은 마이크로서비스에는 권장되지 않음.
  - 2단계 커밋을 지원하는 API가 필요하지만, 구현이 어려움.
  - 분산 트랜잭션 사용 시 **강하게 결합**되어야 하기에, 이는 마이크로서비스 아키텍처에서 권장하지 않는 방식임.
  - 확장이 어려움

##### 이벤트 기반 아키텍처

- 마이크로서비스에서는 그래서 이벤트 기반 아키텍처를 사용합니다

- 시스템의 상태를 변경하는 CASE

  - 첫 번째 서비스가 자체 DB에서 데이터를 변경하고 동일한 내부 트랜잭션에서 이벤트를 **메시지 브로커**에 전달(서비스 경계를 넘지 않음!!!)
  - 두 번째 서비스는 이벤트 메시지를 수신하고 이에 따라 저장 데이터 변경
  - 때에 따라 다시 이벤트를 송신할 수도 있음(**서비스는 동시에 블로킹되지 않으며** 상호 의존성이 없음)
  - 유일한 결합 지점은 **교환하는 메시지**
  - 첫 번째 서비스가 작동하는 시점에 두 번째 서비스가 실행 중이 아니라도 요청에 대한 처리를 계속 할 수 있음 ➡️ 복원력이 높음 ➡️ Reactive

  

- 이전에도 말했지만, 두 서비스가 **수다스러울 정도**로 많은 정보를 교환한다면 서비스 병합을 고려하자.

- 또한 이벤트를 사용해 몇 가지 서비스에 대해 동시에 업데이트를 수행하는 어댑터 서비스를 구현할 수도 있다

##### 궁극적 일관성

- 소프트웨어 시스템에서 분산 트랜잭션을 수행하는 방식을 분석해보자..
- 분산 트랜잭션의 사용은 시스템의 모든 부분에서 항상 **일관성**을 보장할 것이라 확신하지만, **불확실성의 제거**는 매우 제한적인 요구이다?
- DDD 저자 반 버논에 따르면, 불확실성을 도메인 모델에 포함시킬 것을 제안한다. 
  - 책에 따르면 시스템에는 어떤 방식으로든 일관성 없는 상태가 발생할 수 있으며 불확실성이 계속 발생하고 이로 인해 문제가 발생하더라도 이를 비즈니스 워크플로의 일부로 포함시키는 것이 좋다는 것.
- 예로, [결제 정보 확인 중]이라는 새로운 상태를 도입해 결제 정보 확인 없이 주문을 생성할 수도 있다.
  - 이 새로운 상태는 불확실한 상황(결제 정보의 비유효)을 한정된 시간 동안(결제 정보가 확인될 때까지) 유지되는 별도의 비즈니스 이벤트로 다룬다.
  - 이러한 접근 방식을 사용하면 **시스템에서 항상 일관성을 유지할 필요가 없음**
  - 대신 시스템에서 각 비즈니스 트랜잭션의 상태를 관찰하기 위한 일관적인 뷰가 있는지 확인해야 함
  - 이러한 미래의 일관성을 **궁극적 일관성(eventual consistency)**라고 한다.
    - 즉 지금은 두 서버가 일관적이지 않지만, 미래에는 동기화가 되어 일관성을 가지게 될 거야 그러니 일관성에 너무 집중하지 말자라는 말이 아닐까?
  - 대개 궁극적 일관성을 보장한다 ➡️ 운영을 성공적으로 수행할 수 있는 안정적인 시스템으로 볼 수 있음! 

<img src="/Users/seongjayong/Learning/book-spring-reactive/image/그림 7.9 메시지를 이용해 각각의 데이터베이스를 업데이트하는 주문과 결제 서비스.png" alt="그림 7.9 메시지를 이용해 각각의 데이터베이스를 업데이트하는 주문과 결제 서비스" style="zoom:50%;" />

##### SAGA 패턴 ⭐️

- 특히 마이크로서비스 분야에서 분산 트랜잭션에 가장 널리 사용되는 패턴 중 하나가 **SAGA 패턴**이다.
- saga는 소수의 작은 트랜잭션으로 구성되며, 각 트랜잭션은 하나의 마이크로서비스에 국한된다.
- 외부 요청이 saga를 시작하고, saga가 첫 번째 작은 트랜잭션을 시작 ➡️ 성공할 경우, 두 번째 트랜잭션 시작 ➡️ 트랜잭션이 중간에 성공하지 못하면 이전 트랜잭션에 대한 보상 기동
- 이를 구현하는 패턴에는 코레오그래피(event-based choreography)와 오케스트레이션(orchestration via a coordinator service)의 두 가지가 있다.

##### 이벤트 소싱

- 마이크로서비스 응용 프로그램의 이벤트 플로를 처리하기 위해 이벤트 소싱 패턴을 사용할 수 있다
- 이벤트 소싱은 각 비즈니스 엔티티의 상태 변화 순서를 저장.
  - 예를 들어, 은행 계좌는 초기 금액과 예금/인출 순서로 나타낼 수 있다
  - 이 정보를 사용하면 업데이트 이벤트를 순차적으로 복기해 현재 계정 상태를 계산할 수 있을 뿐만 아니라 엔티티 변경 사항에 대한 신뢰할 수 있는 감사 로그를 제공할 수 있다.
  - 현재 상태를 계산하는 데 필요한 시간을 최적화하기 위해 응용 프로그램은 스냅 샷을 주기적으로 작성하고 저장할 수 있음
  - 저장소 크기를 줄이기 위해 선택한 스냅샷 이전의 이벤트를 삭제할 수도 있음
- 이런 단순함에도 불구하고 개발자들에게 익숙하지 않다는 점과 일반적인 프로그래밍 방식과의 차이, 학습 시간이 길다는 이유로 이벤트 소싱은 자주 사용되지 않음.
- 또한 상태를 지속적으로 재계산해야 하기 때문에 이베트 소싱을 사용하면 특히 쿼리가 복잡할 때 효율적인 쿼리를 수행할 수 없음
- 이 경우 CQRS(명령 및 쿼리 책임 분리) 가 도움이 된다.

##### 명령 및 쿼리 책임 분리(CQRS)

- 이벤트 소싱과 함께 사용되며 두 부분으로 구성
  - Write 파트 : 상태 변경 명령을 수신해 이벤트 저장소에 저장
  - Read 파트 : 상태를 변경하지 않고 요청된 쿼리의 결과를 반환.??? 별개의 쿼리에 대한 상태 표현은 뷰로 저장되며, 갱신 이벤트가 명령으로 수신된 후에 비동기식으로 다시 계산됨

<img src="/Users/seongjayong/Learning/book-spring-reactive/image/그림 7.10 CQRS 구현.png" alt="그림 7.10 CQRS 구현" style="zoom:40%;" />

- CQRS 패턴은 소프트웨어 시스템이 대량의 데이터를 스트리밍 방식으로 처리할 수 있도록 해주고, 동시에 현재 시스템 상태와 관련된 다양한 쿼리에 신속하게 응답할 수 있다.

##### 충돌 없는 복제 데이터 타입(CRDT)

- 트랜잭션은 확장성이 좋지 않으며 응용 프로그램이 늘어남에 따라 하나의 마이크로서비스 영역 내에서 글로벌 상태를 일관되게 유지하는 것은 점점 더 어려워진다.
- 따라서 성능 및 시스템 확장성을 위해 글로벌 록이나 트랜잭션 **일관성 없이** **여러 서비스 인스턴스에서 동시에 데이터를 업데이트**하는 경우가 발생할 수 있음
- 이러한 접근 방식을 **낙관적 복제(optimistic replication)**라고 하며, 나중에 발생할 불일치를 감수하면서 데이터 복제본을 병행해서 사용할 수 있음.
- 병합 프로세스가 항상 성공할 수 있도록 하는 수학적 속성을 가진 데이터 구조가 있는데, 이를 **충돌 없는 복제 데이터 타입(CRDT)**라고 한다.
- Cosmos DB, Redis 등 충돌 없는 복제 데이터베이스(CRDB)의 형태로 CRDT를 기본적으로 지원한다.

##### 데이터 저장소로서의 메시징 시스템

- 메시지를 위한 영속성 스토리지를 가진 메시지 브로커가 개별 마이크로서비스를 위한 전용 데이터베이스에 대한 필요성을 감소시킬 수 있다.
- 실제로 모든 엔티티에 대한 업데이트 이벤트(엔티티 스냅샷 포함)가 충분한 시간 동안 메시지 브로커에 저장되고 언제든지 다시 읽을 수 있다면 이 이벤트만으로도 시스템의 전체 상태를 정의할 수 있다.
- 서비스는 새로운 업데이트 명령을 처리하고 쿼리를 읽고 때때로 브로커에 엔티티 스냅샷을 생성하고 보내는 것만으로도 동작할 수 있다..!
- 아파치 카프카에 신뢰할 수 있는 영속성 계층이 있어서 시스템의 주 데이터 저장소로 사용할 수 있을 뿐만 아니라 시스템 내의 유일한 데이터 저장소로도 활용할 수 있다. 

### 데이터 조회를 위한 동기식 모델

- 리엑티브 이전 시대의 애플리케이션이 데이터 액세스를 구현하는 방법을 살펴보자.
- 또한 쿼리를 실행하고 처리할 때 클라이언트와 데이터베이스가 어떻게 통신 하는지, 이러한 통신의 어떤 부분을 비동기적으로 수행할 수 있는지, 리액티브 프로그래밍 패턴을 적용하면 어떤 부분에서 이점을 얻을 수 있는지 알아보자.

#### 데이터베이스 액세스를 위한 와이어 프로토콜

- DB 종류 중 임베디드 데이터베이스가 있으며, 응용 프로그램 프로세스 내에서 실행되므로 네트워크를 통한 통신이 필요하지 않다 - H2 DB
- 대부분 소프트웨어는 별도의 서버(또는 별도의 컨테이너)에서 별도의 프로세스로 실행되는 데이터베이스를 사용한다.
- 응용 프로그램은 **데이터베이스 드라이버**라고 하는 특수한 클라이언트 라이브러리를 사용해 외부 데이터베이스와 통신한다.
- 또한, **와이어 프로토콜**은 데이터베이스 드라이버와 클라이언트와 데이터베이스 간에 전송되는 메시지의 정렬 형식을 정의한다.
- 와이어 프로토콜은 일반적으로 TCP/IP를 이용하도록 설계됐으므로 **블로킹 방식으로 동작할 필요가 없다.**
- 동기적인 HTTP 통신과 마찬가지로 프로토콜 자체가 차단되지는 않지만, 클라이언트가 요청에 대한 결과를 기다리는 동안 차단하는 방식으로 동작하고 있을 뿐이다.
- 와이어 프로토콜은 의도적으로 배압 구현을 위해 다른 메커니즘을 사용하거나 여러 메커니즘을 조합해 사용할 수도 있지만, 내부적으로는 항상 TCP 메커니즘을 사용한다는 사실을 기억하자.
- 데이터베이스 와이어 프로토콜의 기반으로 더 높은 수준의 프로토콜을 사용할 수도 있다.
  - HTTP2, 웹소켓, gRPC, RSocket을 사용할 수 있다.
- 클라이언트와 데이터베이스 간에 큰 데이터를 전달하기 위해 완전히 다른 접근 방식을 사용할 수도 있음
  1. DB 측에서 전체 결과 집합을 계산한 후 쿼리가 끝나자마자 데이터를 컨테이너에 넣고 컨테이너를 클라이언트에 전달하는 방식 => 배압을 고려하지 않으며, 클라이언트에 커다란 버퍼를 필요로 함
  2. 클라이언트가 요청할 때 청크로 결과 집합을 보낼 수도 있음 => 메모리 버퍼 사용량을 줄일 수 있고 배압 전파가 가능하며 쿼리를 취소할 수도 있음
  3. 쿼리 실행 중에 결과를 얻자마자 결과를 스트림으로 보내는 방법 => 데이터 요구량을 알려주어 논리적 배압 조절 가능, 추가 버퍼 거의 필요하지 않음, 단 네트워크와 CPU를 과도하게 사용할 수 있음

- 일반적으로 데이터베이스는 하나 이상의 접근 방법을 이용해 와이어 프로토콜을 구현한다.
  - MySQL은 데이터를 전체 또는 스트림으로 행 단위를 보낼 수 있다
  - PostgreSQL은 PostgreSQL portal 개념을 사용해 클라이언트가 수신할 수 있는 만큼의 데이터 행을 요청할 수 있음.
- 잘 설계된 데이터베이스 와이어 프로토콜은 이미 리액티브의 모든 특성을 가지고 있다..!
- 또한 전체 데이터를 가져오는 방식의 프로토콜조차 배압 전파를 위해 TCP 제어 흐름을 사용할 수 있는 리액티브 드라이버로 래핑할 수 있다.

#### 데이터베이스 드라이버

- **데이터베이스 드라이버**는 데이터베이스 와이어 프로토콜을 메서드 호출이나 콜백, 리액티브 스트림과 같은 프로그래밍 언어로 구현한 라이브러리
- 드라이버를 통한 **외부 데이터베이스와의 통신은 외부 HTTP 서비스와의 통신과 비슷함**
- 이론적으로 데이터베이스 통신 프로토콜에 리액티브 설계를 적용하면 스프링 웹플럭스 모듈의 리액티브 WebClient와 유사한 이점을 얻을 수 있음
- 그림 참조
- 데이터베이스 드라이버의 블로킹 특성은 와이어 프로토콜이 아닌 상위 API에 의해 결정된다.
  - 따라서 리액티브 데이터베이스 드라이버를 구현하는 것이 어려운 일은 아님
  - NoSQL 데이터베이스 드라이버에는 구현할 수 있는 언어별 API가 존재하지 않아 DB별로 API를 비동기 또는 리액티브 스타일로 직접 구현할 수도 있음

#### JDBC

- JDBC는 응용프로그램이 데이터베이스(RDB)와 통신하는 방법을 정의하고 자바 플랫폼에서 데이터 액세스를 위한 표준화된 API를 제공함
- JDBC를 사용하면 여러 데이터베이스를 동일한 응용 프로그램에서 사용할 수 있다.
- JDBC 연결을 사용하면 SQL의 SELECT, CREATE, INSERT, UPDATE 및 DELETE와 같은 명령문을 초기화하고 실행할 수 있다.
- 명령문은 결과의 행에 대한 이터레이터인 java.sql.ResultSet를 반환하며 이는 꽤나 오래된 API임..

#### 커넥션 관리

- 최근 애플리케이션들은 JDBC에 직접 연결하지 않고 커넥션 풀을 사용한다.

<img src="https://hudi.blog/static/1bda5b43f837f4e11d0d6934aa003aa0/e249b/database-connection-pool.png" alt="데이터베이스 커넥션 풀 (Connection Pool)과 HikariCP" style="zoom:20%;" />

- 왜? 새로운 커넥션을 맺는 것은 비용이 많이 듬.
  - 클라이언트 인증 및 권한 부여
  - 데이터베이스 비용 -> 새로운 커넥션이 연결될 때마다 (스레드가 아닌?) 새로운 프로세스를 생성함
- 커넥션 풀은 JDBC 연결에 널리 사용되기는 하지만, 데이터베이스 통신의 고유 영역이 아님

#### 리액티브 방식으로 관계형 데이터베이스 접근하기

- 이 책에 앞에서 블로킹 API가 응용 프로그램의 확장성을 제한하기 때문에 리액티브 응용 프로그램에서 사용하지 않는 것이 좋다고 하였음. -> **리액티브 애플리케이션에서 사용할 언어 수준의 데이터베이스 액세스 API**가 필요함!
- 그림 참조

#### 스프링 JDBC

- 스프링은 꽤 오래됐지만 여전히 많이 사용되는 스프링 JDBC 모듈을 제공함
- 사용 예시는 책 참조
- 스프링 JDBC 모듈은 유틸리티, 헬퍼 클래스, 상위 레벨 추상화에 사용되는 도구로 구성됨.

#### 스프링 데이터 JDBC

- 스프링 데이터의 새로운 모듈

- 스프링 데이터 리포지토리는 에릭 에반스가 DDD에서 설명한 리포지토리에서 영감을 얻었다함.

- 스프링 JDBC는 @Query 애노테이션과 엔티티 라이프 사이클 이벤트를 이용해 간단한 집계를 위한 CRUD 연산을 지원함.

  ~~~java
  class Book {
      @Id
      private int id;
      private String title;
      // ~~~
  }
  ~~~

- 이제, CrudRespository<Book, Integer>를 상속해서 BookRepository 인터페이스를 만들어보자.

  ~~~java
  //CrudRepository 상속으로 CRUD 연산 관련 12가지 메서드 사용 가능
  @Repository
  public interface BookSpringDataJdbcRepository extends CrudRepository<Book, Integer> {
      // ResultSet 변환 등은 내부에서 해줌
      @Query("SELECT * FROM book WHERE LENGTH(title) " + 
  		"(SELECT MAX(LENGTH(title)) FROM book)")
      List<Book> findByLongestTitle();
      
      // Stream 반환도 가능
      @Query("SELECT * FROM book WHERE LENGTH(title) = " +
  		"(SELECT MIN(LENGTH(title)) FROM book)")
  	Stream<Book> findByShortestTitle();
      
      // 비동기 모드, 하지만 JDBC가 블로킹 방식으로 동작하기에 내부적으로 스레드는 락이 걸림
      @Async
      @Query("SELECT * FROM book b"+
      	"WHERE b.title = :title")
      CompletableFuture<Book> findBookByTitleAsync(
          @Param("title") String title);
      
      // CompletableFuture + Stream 으로 그나마 리액티브하게 가능
      // 허나 이 방법도 데이터 청크 검색할 때는 블로킹됨.
      @Async
      @Query("SELECT * FROM book b " +
      	"WHERE b.id > :fromId AND b.id < :toId")
      CompletableFuture<Stream<Book>> findBooksByIdBetweenAsync(
      	@Param("fromId") Integer from,
      	@Param("told") Integer to);
  }
  ~~~

- 스프링 데이터 JDBC는 소규모 마이크로서비스를  위한 간단한 영속성 계층을 구현하는 아주 작고 편리한 모듈

- 그러나 이 모듈은 단순함을 목표로 만들어졌기에, 캐싱, 앤티티의 지연 로드 및 복잡한 엔티티 관계와 같은 ORM을 위해 **JPA**라는 별도의 스펙이 있음.

#### 스프링 데이터 JDBC를 리액티브하게 만들기

- 스프링 데이터 JDBC는 완벽하게 블로킹 API인 JDBC를 필요로 하기 때문에 완전한 리액티브 스택에는 적합하지 않음.
- R2DBC 규격이 개발 중이며, 사용할 상태까지 되어 가는 중이라고 한다.

#### JPA

- 응용 프로그램에서 영속성 계층을 정의하고 구성하는 표준
- 데이터베이스 액세스의 표준이 **JDBC**라면 코드의 객체를 데이터베이스의 테이블에 매핑하는 ORM의 표준이 **JPA**이다.
- 가장 많이 사용되는 JPA 구현체는 Hibernate와 EclipseLink가 있다.
  - Hibernate는 타임스탬프와 내츄럴 ID에 대한 지원이 더 좋음.
- 두 라이브러리 다 멀티 태넌시(하나의 소프트웨어 인스턴스가 서버에서 실행되고 여러 테넌트에게 서비스를 제공하는 소프트웨어 아키텍처)를 지원

#### JPA를 리액티브하게 만들기

- 근시일 내에 JPA의 리액티브화는 없을 것..

#### 스프링 데이터 JPA

- 스프링 데이터 JDBC와 유사한 리포지토리를 만들 수 있지만, 내부적으로는 훨씬 더 강력한 JPA 구현체를 사용함.

- 메서드 이를에 기반한 규칙을 이용해 JPA 쿼리를 생성하고 **제너릭 DAO 패턴**을 구현함

  <img src="https://prashanthkudipudi.files.wordpress.com/2012/10/generic-dao-implementation.jpg" alt="Generic DAO Pattern | SPI Products Platform Solution" style="zoom:50%;" />

- 또한 타입 안정성을 보장하며 자바 기반의 쿼리를 생성해주는 **Querydsl 라이브러리**를 사용할 수 있음

~~~java
@Entity
@Table(name = "book")
public class Book {
    @Id
    private int id;
    private String title;
    
    // ~~~
}
~~~

- JPQL 쿼리에 사용할 엔티티 이름을 설정할 수도 있음
- 메서드 이름에 기반한 쿼리 생성과 JPQL 쿼리를 사용해 쿼리를 수행하는 CRUD 리포지토리를 정의해보자

~~~java
@Repository
interface BookJpaRepository extends CrudRepository<Book, Integer> {
    // 메서드 이름에 기반한 쿼리 생성
    Iterable<Book> findByIdBetween(int lower, int upper);
    
    // JPQL 쿼리를 사용해 쿼리 수행
    @Query("SELECT b FROM Book b WHERE LENGTH(b.title) = " + "(SELECT MIN(LENGTH(b2.title)) FROM Book b2)")
    Iterable<Book> findShortestTitle();
}
~~~

- JDBC 드라이버, 스프링 부트 의존성, Book 엔티티 클래스 및 BookJpaRepository 인터페이스만 있으면 스프링 데이터 JPA 등에 기반한 매우 다양한 영속성 계층 지원이 가능!

#### 스프링 데이터 JPA를 리액티브하게 만들기

- 향후 몇년 동안 가능성은 희박하다고 함..

#### Spring Data NoSQL

- 스프링 데이터 JPA와 스프링 데이터 JDBC는 둘 다 관계형 데이터베이스와 JDBC 드라이버를 연결하기 위한 훌륭한 솔루션이다.
- 하지만 대부분 NoSQL 데이터베이스는 이를 지원하지 않는다.
- 이를 위해 널리 사용되는 NoSQL 데이터베이스를 목표로 하는 몇 개의 개별 모듈이 있음
- 책의 코드를 보며 이해해보자.
- 스프링 프레임워크로 NoSQL 데이터베이스를 리액티브 방식으로 사용하려면 전체 기본 인프라가 리액티브 또는 비동기 API를 제공해야 한다.
- 현재 스프링 데이어테는 몇 가지 리액티브 데이터 커넥터가 있음..!

#### 동기 모델의 한계

- JDBC, JPA, Hibernate, 스프링 데이터 JPA 등등 이들은 본질적으로 **동기식이며 블로킹**이다.
- I/O 요청이 HTTP이든 데이터베이스 요청이든 블로킹 방법으로 만드는 것은 낭비이다.
- JDBC 기반 통신은 일반적으로 컽넥션 풀을 사용해 쿼리를 병렬로 실행한다.
- 반대로 HTTP2 프로토콜을 사용하면 동일한 TCP 연결을 사용해 여러 리소스를 동시에 보내고 받을 수 있다.
- 그림 참조
- 데이터베이스가 멀티플렉싱을 활용할 수 있는 비동기 논블로킹 드라이버를 제공하더라도 JDBC, JPA 또는 스프링 데이터 JPA를 사용해서 최대한의 성능을 얻을 수는 없다..
- 따라서 **완전히 리액티브한 애플리케이션을 구현하려면 동기식 기술을 포기하고 리액티브를 사용해 API를 만들어야 한다!**
- 물론 동기 모델이 나쁜 것은 아니다. 리액티브 분야에 적합하지 않을 뿐이다.

### 동기 모델의 장점

- 블로킹 웹 응용 프로그램을 구축할 때는 매우 유용하다

  - JDBC는 응용 프로그램과 데이터베이스 간의 클라이언트 - 서버 통신의 복잡한 부분을 라이브러리 내에서 구현하고 외부로 노출시키지 않는다.
  - 스프링 데이터 JDBC, JPA는 쿼리 번역 및 트랜잭션 관리의 엄청난 복잡성을 내부적으로 구현했다.

- 테스트가 쉬움

- 배압 지원이 필요하지 않음

- 로컬 및 분산 트랜잭션에 대한 탁월한 지원을 제공

- 유일한 단점? 실행 시점에 블로킹 된다는 것

- 추가로 리액티브 패러다임(네티, 리액터, 웹플럭스)으로 구축한 리액티브 웹 응용 프로그램과는 호환되지 않음.. 

  

- 이제 스프링 데이터 리포지토리의 다양성을 손상시키지 않으면서 **스프링 데이터의 리액티브 커넥터가 어떻게 고성능을 약속하는지** 확인해보자

### 스프링 데이터로 리액티브하게 데이터 접근하기

- 우리는 엔티티 컬렉션을 지원하는 리포지토리가 아닌 **리액티브한 엔티티 스트림으로 동작하는 리포지토리**가 필요함

- 리액티브 타입으로 반환이 가능해야 함

- 개발자들은 데이터베이스를 쿼리할 때  스프링 웹플럭스 모듈의 WebClient와 비슷한 방식으로 데이터 리포지토리를 사용하기를 원할 것이다

- 스프링 데이터 Commons 모듈에는 이러한 동작을 제공하는 **ReactiveCrudRepository 인터페이스**가 포함돼 있다.

- 리액티브 데이터 액세스 계층을 사용할 때 이점

  - 효과적인 스레드 관리 - I/O 작업이 블로킹되지 않음
  - 첫 번째 쿼리 결과에 대한 짧아진 대기 시간 - 쿼리가 끝나기 전에도 사용할 수 있음
  - 낮은 메모리 사용량 - 쿼리 처리 시 버퍼링해야 할 데이터가 적기 때문에 유용
  - 배압 전파 - 데이터를 소비하는 데이터베이스의 능력을 알려줄 수 있음
  - 하나의 커넥션 공유 - 다른 스레드에서 쿼리와 데이터 처리 작업을 보낼 수 있음

  - 연쇄형 API를 사용하는 리액티브 코드와 부드럽게 결합되는 영속성 계층

- 스프링 부트 애플리케이션에서 리액티브 영속성을 사용하려면 리액티브 커넥터가 있는 DB 중 하나를 사용해야 한다.

  - MongoDB, Cassandra, Redis, Couchbase 가 리액티브 연결을 제공한다.

- MongoDB를 이용해 리액티브 CRUD 리포지토리가 어떻게 작동하는지 살펴보자.

#### MongoDB 리액티브 리포지토리

- MongoDB 오브젝트 - 도큐먼트 매핑과 관련된 애노테이션은 동기식 MongoDB 모듈과 리액티브 MongoDB 모듈에서 동일하게 사용가능하나 **리포지토리는 리액티브 타입으로 대체**해야 함

~~~java
// ReactiveMongoRepository : 리액티브 커넥터의 공용 인터페이스인 ReactiveCrudRepository 상속
// ReactiveCrudRepository : CrudRepository 인터페이스에 대한 리액티브 구현
public interface ReactiveSpringDataMongoBookRepository extends ReactiveMongoRepository<Book, Integer> {
    //쿼리 자동 생성
    @Meta(maxScanDocuments = 3) // 쿼리 튜닝 기능. 최대 도큐먼트 수를 뜻하는 듯하나 deprecated됨
    Flux<Book> findByAuthorsOrderByPublishingYearDesc(Flux<String> authors);
    
    // 직접 작성한 MongoDB 쿼리
    @Query("{ 'authors.1': { $exists: true } }")
    Flux<Book> booksWithFewAuthors();
}
~~~

- 페이징 처리는 지원하지 않음.
- 리액티브 리포지토리를 사용해 MongoDB에 몇 권의 책을 추가하는 예제

~~~java
@Autowired
private ReactiveSpringDataMongoBookRepository rxBookRepository;

Flux<Book> books = Flux.just(
	new Book("The Martian", 2011, "Andy Weir"),
	new Book("Blue Mars", 1996, "Kim Stanley Robinson")
);

rxBookRepository
    .saveAll(books) // 엔티티를 저장(실제 구독 전에는 저장되지 않음)
    .then()
    .doOnSuccess(ignore -> log.info("Books saved in DB")) // 완료되면 로그 출력
    .subscribe();
~~~

- 리액티브 스트림을 사용해 MongoDB를 쿼리하는 예제

~~~java
private void reportResults(String message, Flux<Book> books) {
    books
        .map(Book::toString)
        .reduce( // 모든 책의 문자열을 하나의 메시지로 수집
    		new StringBuilder(), (sb, b) -> sb.append(" - ")
        									.append(b)
        									.append("\n"))
        .doOnNext(sb -> log.info(message + "\n{}", sb))
        .subscribe();
}
~~~

~~~java
Flux<Book> allBooks = rxBookRepository.findAll();
reportResults("All books in DB:", allBooks);

Flux<Book> andyWeirBooks = rxBookRepository.findByAuthorsOrderByPublishingYearDesc(Mono.just("Andy Weir"));
reportResults("All books by Andy Weir: ", andyWeirBooks);
~~~

#### 리포지토리 동작 조합하기

- 책의 제목만 알고 있는 상태에서 책의 출판 연도를 업데이트해야 하는 상황
  1. 원하는 책 인스턴스를 찾고
  2. 게시 연도를 업데이트
  3. 책을 데이터베이스에 저장

~~~java
// 유스케이스를 복잡하게 만들기 위해 제목, 연도 값이 약간의 지연을 두고 비동기적으로 검색돼 전달된다고 가정
publicc  Mono<Book> updatedBookYearByTitle(Mono<String> title, Mono<Integer> newPublishingYear)
~~~

- 위 함수의 구현 동작 확인을 위한 테스트 시나리오를 만들어 보자.

~~~java
Instant start = now(); // 시작 시간 저장
Mono<String> title = Mono.delay(Duration.ofSeconds(1))
    	.thenReturn("Artemis")
    	.doOnSubscribe(s -> log.info("Subscribed for title"))
    	.doOnNext(t -> log.info("Book title resolved: {}", t));

Mono<Integer> publishingYear = Mono.delay(Duration.ofSeconds(2))
    	.thenReturn(2017)
    	.doOnSubscribe(s -> log.info("Subscribed for publishing year"))
    	.doOnNext(t -> log.info("New publishing year resolved: {}", t));

updatedBookYearByTitle(title, publishingYear)
    .doOnNext(b -> log.info("Publishing year updated for book: {}", b))
    .hasElement() // onNext 이벤트가 있는지 확인
    .doOnSuccess(status -> log.info("Updated finished {}, took: {}", 
                                    status ? "successfully" : "unsuccessfully",
                                   between(start, now())))
    .subscribe(); // 리액티브 워크플로 시작
~~~

- 첫번째 테스트

~~~java
private Mono<Book> updatedBookYearByTitle(Mono<String> title, Mono<Integer> newPublishingYear) {
    return rxBookRepository.findOneByTitle(title)
        .flatMap(book -> newPublishingYear
                .flatMap(year -> {
                    book.setPublishingYear(year);
                    return rxBookRepository.save(book);
                }))
}

Subscribed for title.
Book title resolved: Artemis
Subscribed for publishing year
New publishing year resolved: 2017
Publishing year updated for book: Book(publishingYear=2017...
Updated finished successfully, took: PT3.027S
~~~

- 문제점? 제목을 받고, 새로운 출판 연도를 구독함 (blocking) - 3초 넘게 걸림
- 2번째 테스트 - zip 메서드 사용

~~~java
private Mono<Book> updatedBookYearByTitle(Mono<String> title, Mono<Integer> newPublishingYear) {
    return Mono.zip(title, newPublishingYear) 
        .flatMap((Tuple2<String, Integer> data) -> {
            String titleVal = data.getT1();
            Integer yearVal = data.getT2();
            return rxBookRepository
                .findOneByTitle(title)
                .flatMap(book -> {
                         book.setPublishingYear(year);
                         return rxBookRepository.save(book);
                }); 
        });
}

Subscribed for title
Subscribed for publishing year
Book title resolved: Artemis
New publishing year resolved: 2017
Publishing year updated for the book: Book(publishingYear=2017...
Updated finished successfully, took: PT2.032S
~~~

- 첫 번째 방법보다는 빠르지만, Tuple2 타입을 사용하기 때문에 추가 코드 라인과 변환 작업이 필요함
- 리액터 애드온 모듈을 추가하는 세번째방법

~~~java
private Mono<Book> updatedBookYearByTitle(Mono<String> title, Mono<Integer> newPublishingYear) {
    return Mono.zip(title, newPublishingYear) 
        .flatMap(
        TupleUtils.function((titleValue, yearValue) -> 
                            rxBookRepository
                                .findOneByTitle(title)
                                .flatMap(book -> {
                                     book.setPublishingYear(year);
                                     return rxBookRepository.save(book);
                				})
                           )
    	);
}
~~~

- 제목 및 새로운 발행 연도를 모두 받은 후에만 데이터베이스에 책을 검사하라는 명령을 보내는데, 게시 연도 요청이 아직 진행 중이더라도 제목이 이미 있는 경우 책 검색을 시작할 수 있음

~~~java
private Mono<Book> updatedBookYearByTitle(Mono<String> title, Mono<Integer> newPublishingYear) {
    return Mono.zip(newPublishingYear, rxBookRepository.findOneByTitle(title)) 
        .flatMap(function((yearValue, bookValue) -> {
            bookValue.setPublishingYear(yearValue);
            return rxBookRepository.save(bookValue);
        }));
}
~~~

- 리액티브 파이프라인을 작성할 때 리액티브 연산자의 다른 조합을 고려하고 가장 먼저 생각나는 옵션을 선택하지 말고 비즈니스 요청에 가장 적합한 옵션을 선택하자..!

















