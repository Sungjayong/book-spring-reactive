## 07장 리액티브 방식으로 데이터베이스 사용하기

Spring Data 모듈을 사용해 리액티브 방식으로 데이터에 액세스하는 방법을 학습해보자.

선택한 DB가 리액티브 또는 비동기 드라이버를 제공하지 않더라도 **전용 스레드 풀**을 사용해 리액티브 응용 프로그램을 구축하는 방법을 알아보자.

- 최근 데이터 저장 및 처리 패턴
- 동기식 데이터 액세스의 장단점
- 스프링 데이터가 리액티브 데이터 액세스를 처리하는 방법
- 리액티브 애플리케이션에서 스프링 데이터를 사용하는 방법
- 현재 사용 가능한 리액티브 커넥터
- 블로킹 I/O에 리액티브 프로그래밍 모델을 적용하는 방법


### 최근 데이터 처리 패턴

- 마이크로서비스 패턴은 최근 응용 프로그램, 특히 **클라우드 네이티브 애플리케이션**에서 가장 중요한 아키텍처 스타일이다.
  - Cloud-native applications are a collection of small, independent, and loosely coupled services.
- 마이크로서비스의 관점에서 데이터 저장에 대한 기본 개념, 사용 가능한 전략, 구현 방법 및 데이터 영속화와 관련된 몇 가지 권장 사항을 살펴보자.

#### 도메인 주도 설계

- 에릭 에반스가 쓴 도메인 주도 설계는 모든 소프트웨어 엔지니어의 책장 가장 잘 보이는 자리에 꽂아둬야 한다.

- DDD(Domain-driven design)는 공통 어휘(즉, 컨텍스트, 도메인, 모델 및 유비쿼터스 언어)를 설정하고 모델의 무결성을 유지하기 위한 일련의 원칙을 공식화한다.

- DDD의 관점에서 정의한 각각의 바운디드 컨텍스트(bounded context)가 하나의 마이크로서비스로 매핑된다.

  <img src="/Users/seongjayong/Learning/book-spring-reactive/image/그림 7.1 바운디드 컨텍스트.png" alt="그림 7.1 바운디드 컨텍스트" style="zoom:30%;" /> 

- DDD는 비즈니스 핵심 도메인에 집중하며, 그 중에서도 특히 도메인 모델을 표현, 생성, 검색하는 수단에 중점을 두고 있음.
- 엔티티, 데이터 전달 객체(VO, value object), 애그리게이트(aggregate), repository
- DDD를 염두에 두고 애플리케이션을 구현한다면 앞에서 언급한 객체는 서비스의 영속 계층과 매핑해야 한다.

#### 마이크로서비스 시대의 데이터 저장소

- 마이크로서비스 아키텍처가 도입됨에 따라 영속 계층에 생긴 가장 큰 변화라고 한다면 서비스 간에 데이터 저장소를 공유하지 않게 된 것이다.

  - 즉, 논리적으로 분할된 각각의 서비스가 DB를 소유하고 관리하는 경우, 서비스 API 호출을 제외한 방식으로는 다른 서비스의 데이터에 액세스할 수 없는 것이 이상적

- 물리적으로 보면 스토리지 분리는 몇 가지 방식으로 구현할 수 있음

  1. 하나의 DB 서버를 두고 각각의 서비스에 대해 별도의 스키마를 할당하는 것

  <img src="/Users/seongjayong/Learning/book-spring-reactive/image/그림 7.3 스키마로 서비스 분리.png" alt="그림 7.3 스키마로 서비스 분리" style="zoom:40%;" />

  - 구현이 쉽고 서버 리소스를 적게 필요로 하며, 실제 운영 환경에서 많은 관리 작업을 필요로 하지 않으므로 응용 프로그램 개발 초기 단계에서 좋음.

  - 데이터 분리는 데이터베이스 액세스 제어 규칙을 사용해 강제할 수 있다?

  - 개발자가 하나 이상의 쿼리를 작성해 둘 이상의 서비스에 속한 데이터를 검색하거나 변경할 수 있기에, 서비스를 손상시킬 수도 있음. ➡️ 보안 위협

  2. 하나의 데이터베이스 서버를 공유하지만, 다른 액세스 권한을 가지고 별도의 데이터베이스를 보유하는 방식

     <img src="/Users/seongjayong/Learning/book-spring-reactive/image/그림 7.4 데이터베이스로 서비스 분리.png" alt="그림 7.4 데이터베이스로 서비스 분리" style="zoom:40%;" />

     - 단일 쿼리를 통해 다른 서비스의 데이터에 액세스하는 것이 훨씬 어렵기 때문에 데이터 분리 관점에서는 더 나은 결과를 낼 수 있음
     - 백업 작업을 약간 복잡하게 만듬.

  3. 서비스마다 별도의 데이터베이스 서버 생성

     <img src="/Users/seongjayong/Learning/book-spring-reactive/image/그림 7.5 데이터베이스 서버로 서비스 분리.png" alt="그림 7.5 데이터베이스 서버로 서비스 분리" style="zoom:40%;" />

     - 각각의 데이터베이스 서버를 세부적으로 설정해 서비스가 가진 고유한 요구 사항을 충족시킬 수 있음
     - 특정 서비스의 확장이 필요한 경우 해당 데이터베이스 서버만 쉽게 수직 또는 수평으로 확장할 수 있음

  4. 혼합도 가능

     - 다른 종류의 데이터베이스 서버를 동시에 사용하는 것도 가능하며, 다른 종류의 데이터베이스(SQL, NoSQL)을 함께 사용해 최상의 결과를 얻을 수도 있음
     - 이러한 접근법을 **다중 저장소 영속화(polyglot persistence)**라고 한다.

#### 다중 저장소 영속화

- ㅋZ다중 언어 프로그래밍 ➡️ 비즈니스 또는 기술적인 맥락에서 소프트웨어 시스템을 만들기 위한 가장 적합한 언어를 사용해 최고의 효과를 얻기 위해 여러 가지 언어로 작성할 수 있다는 생각을 표현한 것
- 데이터 영속성 분야에서도 이와 유사한 생각의 변화가 있었음
  - 예로, 분산 웹 애플리케이션을 위한 HTTP 세션을 저장하는 것과 소셜 네트워크에 친구 그래프를 저장하는 것은 서로의 특성이 다르기 때문에 다른 DB를 필요한다.
- 대부분의 RDBMS는 동일한 ACID 원칙을 토대로 구축됐으며 스토리지와 통신하기 위해 거의 유사한 SQL 언어를 제공함.
- 일반적으로 RDBMS는 광범위한 응용 프로그램엔 적합하지만, 그래프 저장, 메모리 내 저장소 및 분산 저장소 등에 대해 최상의 성능 및 관리 기능을 제공하는 경우는 거의 없음.
- 반면, 최근에 등장한 NoSQL 데이터베이스는 광범위한 기본 원칙을 가지고 있어 범용 데이터 저장소로 효율적으로 사용할 수는 없음 
- Redis -> 캐시의 성격
- MongoDB -> 스키마를 깰 수 있는 자유도
- cassandra -> write 성능이 중요
- PostgreSQL -> 정확성이 중요 (RDB)

<img src="/Users/seongjayong/Learning/book-spring-reactive/image/그림 7.7 각각의 서비스에 가장 적합한 영속화 기술을 사용하는 설계.png" alt="그림 7.7 각각의 서비스에 가장 적합한 영속화 기술을 사용하는 설계" style="zoom:50%;" />

- 다중 언어 영속성은 복잡성으로 인해 추가 비용이 발생함
  - 새로운 스토리지 매커니즘마다 새로운 API, 데이터 패러다임, 라이브러리, 개발과 생산에서 다루기 위한 새로운 일련의 표준을 배워야 함.
  - NoSQL을 잘못 사용했다가는 서비스를 처음부터 다시 설계해야 할 수도 있음
- 스프링 프레임워크는 **스프링 데이터**라는 데이터 영속성을 위한 하위 프로젝트를 가지고 있음.
- 이에 대해 알아보자..!

#### 서비스로서의 데이터베이스

- 마이크로서비스 아키텍처에서는 모든 서비스가 상태에 의존적이지 않으며, 모든 상태 정보는 데이터 지속성을 관리하는 방법을 알고 있는 특수 서비스?에 저장된다. ➡️ DB나 Cache를 말하는 듯?
- 클라우드 환경에서는 서비스가 상태를 저장하지 않음으로써 효율적으로 확장할 수 있고 높은 가용성을 가질 수 있다
- 클라우드용으로 설계되지 않은 데이터베이스 서버를 효율적으로 관리하고 조정하는 것은 꽤나 어려운 일
- 대부분 클라우드 제공 업체는 데이터베이스를 서비스(DBaaS)로 제공해 이러한 문제를 해결
  - 이러한 스토리지 솔루션은 일반 데이터베이스(MySQL, PostgreSQL 및 Redis)를 약간 수정해서 제공하거나 애초에 클라우드용으로 설계됨(AWS Redshift, 구글 BigTable 및 마이크로소프트 CosmosDB)
- 일반적으로 클라우드 저장소나 DB에서 사용하는 알고리즘은 다음과 같은 방식으로 동작함.
  1. 클라이언트가 데이터베이스 또는 파일 저장 영역에 대한 액세스 요청
  2. 클라우드 공급자는 데이터 영역에 접근할 수 있는 API 또는 서버 자원에 대한 권한을 부여, 이 때 클라이언트는 제공되는 API의 세부 구현에 대해서는 신경 쓰지 않음
  3. 클라이언트는 액세스 자격 증명을 제공하는 **스토리지 API** 또는 **데이터베이스 드라이버를 사용**
  4. 클라우드 공급자는 클라이언트의 지불 방법, 저장된 데이터 크기, 쿼리 빈도, 동시 접속 또는 기타 특성에 따라 클라이언트에게 요금 부과
- 클라우드 공급 업체는 클라이언트 데이터를 저장하고 처리하는 가장 효율적인 방법을 구현해 기반 인프라에 대한 지출 최소화
- 클라이언트는 핵심 비즈니스 목표 달성에 집중하며 데이터베이스 서버 복제 또는 백업을 구성하는 데 들어가는 시간 낭비 최소화
- 잘 알려진 클라우드 기반 데이터 저장소 및 DB 서비스는 AWS S3, AWS DynamoDB, Heroic PostgreSQL 등등이 있음..

#### 마이크로서비스 사이의 데이터 공유

- 실제 비즈니스 시스템에서는 클라이언트 요청을 처리하기 위해 두 개 이상의 서비스가 소유한 데이터를 쿼리해야 하는 경우가 있음
- 단일 조인 쿼리는 마이크로서비스에서는 금지됨.
- **다중 서비스 요청**을 처리하려면 주문 및 결제 서비스를 모두 쿼리하고 필요한 데이터를 변환해 집계 결과를 클라이언트에 반환하는 어댑터 서비스를 구현해야 함
- 또한 두 서비스 사이에 데이터 요청이 많거나 의존성이 강한 경우에는 DDD를 손상시키지 않는 경우에 한해서 하나의 서비스로 병합하는 게 나음

<img src="/Users/seongjayong/Learning/book-spring-reactive/image/그림 7.8 주문 서비스와 결제 서비스의 데이터를 집계하는 어댑터 서비스.png" alt="그림 7.8 주문 서비스와 결제 서비스의 데이터를 집계하는 어댑터 서비스" style="zoom:50%;" />

- 데이터를 조회하는 것은 매우 간단하지만, 한 번에 몇 가지 서비스를 동시에 업데이트하는 것은 훨씬 어려움.
  - 고객이 주문을 요청했지만, 재고가 충분한지와 결제 정보가 유효한지를 확인하는 것만 가능하다고 가정하자.
  - 모든 서비스에는 자체 DB가 있으므로 워크플로 내에서 두 개 이상의 마이크로서비스와 데이터베이스가 비즈니스 트랜잭션에 참여함.
  - 가장 많이 사용되는 두 가지 방법은 **분산 트랜잭션**과 **이벤트 기반 아키텍처**이다.

##### 분산 트랜잭션

- 네트워크가 분리된 두 개 이상의 컴퓨터 시스템에 저장된 데이터를 업데이트하는 트랜잭션
  - 다시 말해, 어떤 행동이 일어났는지에 대해 여러 개의 서비스가 동시에 동의한다는 뜻.
  - 실제로 대부분 데이터베이스 시스템은 강력하고 엄격한 2단계 록(two-phase locking)을 사용해 글로벌 직렬성(순차성?)을 보장
- 분산 트랜잭션은 데이터 저장소를 원자적으로 업데이트하기 위해 서비스에서 자주 사용됨
- 이 방식은 또한 장애 발생 시 복구에도 유용함
- 하지만, 분산 트랜잭션은 마이크로서비스에는 권장되지 않음.
  - 2단계 커밋을 지원하는 API가 필요하지만, 구현이 어려움.
  - 분산 트랜잭션 사용 시 **강하게 결합**되어야 하기에, 이는 마이크로서비스 아키텍처에서 권장하지 않는 방식임.
  - 확장이 어려움

##### 이벤트 기반 아키텍처

- 마이크로서비스에서는 그래서 이벤트 기반 아키텍처를 사용합니다

- 시스템의 상태를 변경하는 CASE

  - 첫 번째 서비스가 자체 DB에서 데이터를 변경하고 동일한 내부 트랜잭션에서 이벤트를 **메시지 브로커**에 전달(서비스 경계를 넘지 않음!!!)
  - 두 번째 서비스는 이벤트 메시지를 수신하고 이에 따라 저장 데이터 변경
  - 때에 따라 다시 이벤트를 송신할 수도 있음(**서비스는 동시에 블로킹되지 않으며** 상호 의존성이 없음)
  - 유일한 결합 지점은 **교환하는 메시지**
  - 첫 번째 서비스가 작동하는 시점에 두 번째 서비스가 실행 중이 아니라도 요청에 대한 처리를 계속 할 수 있음 ➡️ 복원력이 높음 ➡️ Reactive

  

- 이전에도 말했지만, 두 서비스가 **수다스러울 정도**로 많은 정보를 교환한다면 서비스 병합을 고려하자.

- 또한 이벤트를 사용해 몇 가지 서비스에 대해 동시에 업데이트를 수행하는 어댑터 서비스를 구현할 수도 있다

##### 궁극적 일관성

- 소프트웨어 시스템에서 분산 트랜잭션을 수행하는 방식을 분석해보자..
- 분산 트랜잭션의 사용은 시스템의 모든 부분에서 항상 **일관성**을 보장할 것이라 확신하지만, **불확실성의 제거**는 매우 제한적인 요구이다?
- DDD 저자 반 버논에 따르면, 불확실성을 도메인 모델에 포함시킬 것을 제안한다. 
  - 책에 따르면 시스템에는 어떤 방식으로든 일관성 없는 상태가 발생할 수 있으며 불확실성이 계속 발생하고 이로 인해 문제가 발생하더라도 이를 비즈니스 워크플로의 일부로 포함시키는 것이 좋다는 것.
- 예로, [결제 정보 확인 중]이라는 새로운 상태를 도입해 결제 정보 확인 없이 주문을 생성할 수도 있다.
  - 이 새로운 상태는 불확실한 상황(결제 정보의 비유효)을 한정된 시간 동안(결제 정보가 확인될 때까지) 유지되는 별도의 비즈니스 이벤트로 다룬다.
  - 이러한 접근 방식을 사용하면 **시스템에서 항상 일관성을 유지할 필요가 없음**
  - 대신 시스템에서 각 비즈니스 트랜잭션의 상태를 관찰하기 위한 일관적인 뷰가 있는지 확인해야 함
  - 이러한 미래의 일관성을 **궁극적 일관성(eventual consistency)**라고 한다.
    - 즉 지금은 두 서버가 일관적이지 않지만, 미래에는 동기화가 되어 일관성을 가지게 될 거야 그러니 일관성에 너무 집중하지 말자라는 말이 아닐까?
  - 대개 궁극적 일관성을 보장한다 ➡️ 운영을 성공적으로 수행할 수 있는 안정적인 시스템으로 볼 수 있음! 

<img src="./image/그림 7.9 메시지를 이용해 각각의 데이터베이스를 업데이트하는 주문과 결제 서비스.png" alt="그림 7.9 메시지를 이용해 각각의 데이터베이스를 업데이트하는 주문과 결제 서비스" style="zoom:50%;" />

##### SAGA 패턴 ⭐️

- 특히 마이크로서비스 분야에서 분산 트랜잭션에 가장 널리 사용되는 패턴 중 하나가 **SAGA 패턴**이다.
- saga는 소수의 작은 트랜잭션으로 구성되며, 각 트랜잭션은 하나의 마이크로서비스에 국한된다.
- 외부 요청이 saga를 시작하고, saga가 첫 번째 작은 트랜잭션을 시작 ➡️ 성공할 경우, 두 번째 트랜잭션 시작 ➡️ 트랜잭션이 중간에 성공하지 못하면 이전 트랜잭션에 대한 보상 기동
- 이를 구현하는 패턴에는 코레오그래피(event-based choreography)와 오케스트레이션(orchestration via a coordinator service)의 두 가지가 있다.

##### 이벤트 소싱

- 마이크로서비스 응용 프로그램의 이벤트 플로를 처리하기 위해 이벤트 소싱 패턴을 사용할 수 있다
- 이벤트 소싱은 각 비즈니스 엔티티의 상태 변화 순서를 저장.
  - 예를 들어, 은행 계좌는 초기 금액과 예금/인출 순서로 나타낼 수 있다
  - 이 정보를 사용하면 업데이트 이벤트를 순차적으로 복기해 현재 계정 상태를 계산할 수 있을 뿐만 아니라 엔티티 변경 사항에 대한 신뢰할 수 있는 감사 로그를 제공할 수 있다.
  - 현재 상태를 계산하는 데 필요한 시간을 최적화하기 위해 응용 프로그램은 스냅 샷을 주기적으로 작성하고 저장할 수 있음
  - 저장소 크기를 줄이기 위해 선택한 스냅샷 이전의 이벤트를 삭제할 수도 있음
- 이런 단순함에도 불구하고 개발자들에게 익숙하지 않다는 점과 일반적인 프로그래밍 방식과의 차이, 학습 시간이 길다는 이유로 이벤트 소싱은 자주 사용되지 않음.
- 또한 상태를 지속적으로 재계산해야 하기 때문에 이베트 소싱을 사용하면 특히 쿼리가 복잡할 때 효율적인 쿼리를 수행할 수 없음
- 이 경우 CQRS(명령 및 쿼리 책임 분리) 가 도움이 된다.

##### 명령 및 쿼리 책임 분리(CQRS)

- 이벤트 소싱과 함께 사용되며 두 부분으로 구성
  - Write 파트 : 상태 변경 명령을 수신해 이벤트 저장소에 저장
  - Read 파트 : 상태를 변경하지 않고 요청된 쿼리의 결과를 반환. 별개의 쿼리에 대한 상태 표현은 뷰로 저장되며, 갱신 이벤트가 명령으로 수신된 후에 비동기식으로 다시 계산됨

<img src="/Users/seongjayong/Learning/book-spring-reactive/image/그림 7.10 CQRS 구현.png" alt="그림 7.10 CQRS 구현" style="zoom:40%;" />

- CQRS 패턴은 소프트웨어 시스템이 대량의 데이터를 스트리밍 방식으로 처리할 수 있도록 해주고, 동시에 현재 시스템 상태와 관련된 다양한 쿼리에 신속하게 응답할 수 있다.

##### 충돌 없는 복제 데이터 타입(CRDT)

- 트랜잭션은 확장성이 좋지 않으며 응용 프로그램이 늘어남에 따라 하나의 마이크로서비스 영역 내에서 글로벌 상태를 일관되게 유지하는 것은 점점 더 어려워진다.
- 따라서 성능 및 시스템 확장성을 위해 글로벌 록이나 **트랜잭션** **일관성 없이** **여러 서비스 인스턴스에서 동시에 데이터를 업데이트**하는 경우가 발생할 수 있음
- 이러한 접근 방식을 **낙관적 복제(optimistic replication)**라고 하며, 나중에 발생할 불일치를 감수하면서 데이터 복제본을 병행해서 사용할 수 있음.
- 병합 프로세스가 항상 성공할 수 있도록 하는 수학적 속성을 가진 데이터 구조가 있는데, 이를 **충돌 없는 복제 데이터 타입(CRDT)**라고 한다.
  - Vector Clock
  - Call count와 같이 그냥 합치면 되는 데이터가 예시

- Cosmos DB, Redis 등 충돌 없는 복제 데이터베이스(CRDB)의 형태로 CRDT를 기본적으로 지원한다.

##### 데이터 저장소로서의 메시징 시스템

- 메시지를 위한 영속성 스토리지를 가진 메시지 브로커가 개별 마이크로서비스를 위한 전용 데이터베이스에 대한 필요성을 감소시킬 수 있다.
- 실제로 모든 엔티티에 대한 업데이트 이벤트(엔티티 스냅샷 포함)가 충분한 시간 동안 메시지 브로커에 저장되고 언제든지 다시 읽을 수 있다면 이 이벤트만으로도 시스템의 전체 상태를 정의할 수 있다.
- 서비스는 새로운 업데이트 명령을 처리하고 쿼리를 읽고 때때로 브로커에 엔티티 스냅샷을 생성하고 보내는 것만으로도 동작할 수 있다..!
- 아파치 카프카에 신뢰할 수 있는 영속성 계층이 있어서 시스템의 주 데이터 저장소로 사용할 수 있을 뿐만 아니라 시스템 내의 유일한 데이터 저장소로도 활용할 수 있다. 

--------------

### 데이터 조회를 위한 동기식 모델

- 리엑티브 이전 시대의 애플리케이션이 데이터 액세스를 구현하는 방법을 살펴보자.
- 또한 쿼리를 실행하고 처리할 때 클라이언트와 데이터베이스가 어떻게 통신 하는지, 이러한 통신의 어떤 부분을 비동기적으로 수행할 수 있는지, 리액티브 프로그래밍 패턴을 적용하면 어떤 부분에서 이점을 얻을 수 있는지 알아보자.

#### 데이터베이스 액세스를 위한 와이어 프로토콜

- The MongoDB Wire Protocol is a simple **socket-based, request-response style protocol**. Clients **communicate with the database server** through a regular TCP/IP socket.
- DB 종류 중 **임베디드 데이터베이스**가 있으며, 응용 프로그램 프로세스 내에서 실행되므로 **네트워크를 통한 통신이 필요하지 않다** ➡️ H2 DB
- 그러나 대부분 소프트웨어는 별도의 서버(또는 별도의 컨테이너)에서 별도의 프로세스로 실행되는 데이터베이스를 사용한다.
- 응용 프로그램은 **데이터베이스 드라이버**라고 하는 특수한 클라이언트 라이브러리를 사용해 외부 데이터베이스와 통신한다.
- 또한, **와이어 프로토콜**은 데이터베이스 드라이버와 데이터베이스 자체 간에 전송되는 메시지의 정렬 형식을 정의한다.
- 와이어 프로토콜은 일반적으로 TCP/IP를 이용하도록 설계됐으므로 **블로킹 방식으로 동작할 필요가 없다.**
  - 동기적인 HTTP 통신과 마찬가지로 프로토콜 자체가 차단되지는 않지만, 클라이언트가 요청에 대한 결과를 기다리는 동안 차단하는 방식으로 동작하고 있을 뿐이다?

- 데이터베이스 와이어 프로토콜의 기반으로 더 높은 수준의 프로토콜을 사용할 수도 있다.
  - HTTP2, 웹소켓, gRPC, RSocket을 사용할 수 있다.
- 클라이언트와 데이터베이스 간에 큰 데이터를 전달하기 위해 완전히 다른 접근 방식을 사용할 수도 있음
- 클라이언트가 수백만 개의 행을 검색해야 할 때 결과를 전달하는 방법
  1. DB 측에서 **전체 결과 집합을 계산**한 후 쿼리가 끝나자마자 데이터를 컨테이너에 넣고 컨테이너를 클라이언트에 전달하는 방식 ➡️ 배압을 고려하지 않으며, 클라이언트에 커다란 버퍼를 필요로 함
  2. 클라이언트가 요청할 때 **청크로 결과 집합**을 보낼 수도 있음 ➡️ 메모리 버퍼 사용량을 줄일 수 있고 배압 전파가 가능하며 쿼리를 취소할 수도 있음
     - Chunk : 작업할 데이터의 각 commit 사이에 처리되는 row의 수
  3. 쿼리 실행 중에 결과를 얻자마자 **결과를 스트림으로 보내는** 방법 ➡️ 데이터 요구량을 알려주어 논리적 배압 조절 가능, 추가 버퍼 거의 필요하지 않음, 단 네트워크와 CPU를 과도하게 사용할 수 있음
- 일반적으로 데이터베이스는 위 중? 하나 이상의 접근 방법을 이용해 와이어 프로토콜을 구현한다.
  - MySQL은 데이터를 전체 또는 스트림으로 행 단위를 보낼 수 있다
  - PostgreSQL은 PostgreSQL portal이라는 개념을 사용해 클라이언트가 수신할 수 있는 만큼의 데이터 행을 요청할 수 있음.
- 잘 설계된 데이터베이스 와이어 프로토콜은 이미 **리액티브**의 모든 특성을 가지고 있다..!
- 또한 전체 데이터를 가져오는 방식의 프로토콜조차 배압 전파를 위해 TCP 제어 흐름을 사용할 수 있는 리액티브 드라이버로 래핑할 수 있다.

#### 데이터베이스 드라이버

- **데이터베이스 드라이버**는 데이터베이스 와이어 프로토콜을 메서드 호출이나 콜백, 리액티브 스트림과 같은 프로그래밍 언어로 구현한 라이브러리
  - RDB의 경우 드라이버는 각 언어별 API를 구현한다.(JDBC 같은)

- 드라이버를 통한 외부 데이터베이스와의 통신은 외부 **HTTP** 서비스와의 통신과 비슷함
- 데이터베이스 통신 프로토콜에 리액티브 설계를 적용하면 스프링 웹플럭스 모듈의 리액티브 WebClient와 유사한 이점을 얻을 수 있음
- 그림 참조
- 데이터베이스 드라이버의 블로킹 특성은 와이어 프로토콜이 아닌 상위 API에 의해 결정된다.
  - 따라서 리액티브 데이터베이스 드라이버를 구현하는 것이 어려운 일은 아님
  - NoSQL 데이터베이스 드라이버에는 구현할 수 있는 언어별 API가 존재하지 않아 DB별로 API를 비동기 또는 리액티브 스타일로 직접 구현할 수도 있음
  - 현재 Spring Data에서 공식적으로 Reactive 드라이버를 지원하는 데이터베이스는 Redis, MongoDB, Cassandra, Couchbase 정도가 있다. (https://d2.naver.com/helloworld/6080222)

#### JDBC

- JDBC는 응용프로그램이 데이터베이스(RDB)와 통신하는 방법을 정의하고 자바 플랫폼에서 데이터 액세스를 위한 표준화된 API를 제공함
- JDBC를 사용하면 여러 데이터베이스를 동일한 응용 프로그램에서 사용할 수 있다.
- JDBC 연결을 사용하면 SQL의 SELECT, CREATE, INSERT, UPDATE 및 DELETE와 같은 명령문을 초기화하고 실행할 수 있다.
- 명령문은 결과의 행에 대한 이터레이터인 java.sql.ResultSet를 반환하며 이는 꽤나 오래된 API임..

#### 커넥션 관리

- 최근 애플리케이션들은 JDBC에 직접 연결하지 않고 커넥션 풀을 사용한다.

<img src="https://hudi.blog/static/1bda5b43f837f4e11d0d6934aa003aa0/e249b/database-connection-pool.png" alt="데이터베이스 커넥션 풀 (Connection Pool)과 HikariCP" style="zoom:20%;" />

- 왜? 새로운 커넥션을 맺는 것은 비용이 많이 듬.
  - 클라이언트 인증 및 권한 부여
  - 데이터베이스 비용 -> 새로운 커넥션이 연결될 때마다 (스레드가 아닌?) 새로운 프로세스를 생성함
- 커넥션 풀은 JDBC 연결에 널리 사용되기는 하지만, 데이터베이스 통신의 고유 영역이 아님

#### 리액티브 방식으로 관계형 데이터베이스 접근하기

- 이 책에 앞에서 블로킹 API가 응용 프로그램의 확장성을 제한하기 때문에 리액티브 응용 프로그램에서 사용하지 않는 것이 좋다고 하였음. -> **리액티브 애플리케이션에서 사용할 언어 수준의 데이터베이스 액세스 API**가 필요함!
- 그림 참조

#### 스프링 JDBC

- 스프링은 꽤 오래됐지만 여전히 많이 사용되는 스프링 JDBC 모듈을 제공함
- 사용 예시는 책 참조
- 스프링 JDBC 모듈은 유틸리티, 헬퍼 클래스, 상위 레벨 추상화에 사용되는 도구로 구성됨.

#### 스프링 데이터 JDBC

- 스프링 데이터의 새로운 모듈

- 스프링 데이터 리포지토리는 에릭 에반스가 DDD에서 설명한 리포지토리에서 영감을 얻었다함.

- 스프링 JDBC는 @Query 애노테이션과 엔티티 라이프 사이클 이벤트를 이용해 간단한 집계를 위한 CRUD 연산을 지원함.

  ~~~java
  class Book {
      @Id
      private int id;
      private String title;
      // ~~~
  }
  ~~~

- 이제, CrudRespository<Book, Integer>를 상속해서 BookRepository 인터페이스를 만들어보자.

  ~~~java
  //CrudRepository 상속으로 CRUD 연산 관련 12가지 메서드 사용 가능
  @Repository
  public interface BookSpringDataJdbcRepository extends CrudRepository<Book, Integer> {
      // ResultSet 변환 등은 내부에서 해줌
      @Query("SELECT * FROM book WHERE LENGTH(title) " + 
  		"(SELECT MAX(LENGTH(title)) FROM book)")
      List<Book> findByLongestTitle();
      
      // Stream 반환도 가능
      @Query("SELECT * FROM book WHERE LENGTH(title) = " +
  		"(SELECT MIN(LENGTH(title)) FROM book)")
  	Stream<Book> findByShortestTitle();
      
      // 비동기 모드, 하지만 JDBC가 블로킹 방식으로 동작하기에 내부적으로 스레드는 락이 걸림
      @Async
      @Query("SELECT * FROM book b"+
      	"WHERE b.title = :title")
      CompletableFuture<Book> findBookByTitleAsync(
          @Param("title") String title);
      
      // CompletableFuture + Stream 으로 그나마 리액티브하게 가능
      // 허나 이 방법도 데이터 청크 검색할 때는 블로킹됨.
      @Async
      @Query("SELECT * FROM book b " +
      	"WHERE b.id > :fromId AND b.id < :toId")
      CompletableFuture<Stream<Book>> findBooksByIdBetweenAsync(
      	@Param("fromId") Integer from,
      	@Param("told") Integer to);
  }
  ~~~

- 스프링 데이터 JDBC는 소규모 마이크로서비스를  위한 간단한 영속성 계층을 구현하는 아주 작고 편리한 모듈

- 그러나 이 모듈은 단순함을 목표로 만들어졌기에, 캐싱, 앤티티의 지연 로드 및 복잡한 엔티티 관계와 같은 ORM을 위해 **JPA**라는 별도의 스펙이 있음.

#### 스프링 데이터 JDBC를 리액티브하게 만들기

- 스프링 데이터 JDBC는 완벽하게 블로킹 API인 JDBC를 필요로 하기 때문에 완전한 리액티브 스택에는 적합하지 않음.
- R2DBC 규격이 개발 중이며, 사용할 상태까지 되어 가는 중이라고 한다.

#### JPA

- 응용 프로그램에서 영속성 계층을 정의하고 구성하는 표준
- 데이터베이스 액세스의 표준이 **JDBC**라면 코드의 객체를 데이터베이스의 테이블에 매핑하는 ORM의 표준이 **JPA**이다.
- 가장 많이 사용되는 JPA 구현체는 Hibernate와 EclipseLink가 있다.
  - Hibernate는 타임스탬프와 내츄럴 ID에 대한 지원이 더 좋음.
- 두 라이브러리 다 멀티 태넌시(하나의 소프트웨어 인스턴스가 서버에서 실행되고 여러 테넌트에게 서비스를 제공하는 소프트웨어 아키텍처)를 지원

#### JPA를 리액티브하게 만들기

- 근시일 내에 JPA의 리액티브화는 없을 것..

#### 스프링 데이터 JPA

- 스프링 데이터 JDBC와 유사한 리포지토리를 만들 수 있지만, 내부적으로는 훨씬 더 강력한 JPA 구현체를 사용함.

- 메서드 이를에 기반한 규칙을 이용해 JPA 쿼리를 생성하고 **제너릭 DAO 패턴**을 구현함

  <img src="https://prashanthkudipudi.files.wordpress.com/2012/10/generic-dao-implementation.jpg" alt="Generic DAO Pattern | SPI Products Platform Solution" style="zoom:50%;" />

- 또한 타입 안정성을 보장하며 자바 기반의 쿼리를 생성해주는 **Querydsl 라이브러리**를 사용할 수 있음

~~~java
@Entity
@Table(name = "book")
public class Book {
    @Id
    private int id;
    private String title;
    
    // ~~~
}
~~~

- JPQL 쿼리에 사용할 엔티티 이름을 설정할 수도 있음
- 메서드 이름에 기반한 쿼리 생성과 JPQL 쿼리를 사용해 쿼리를 수행하는 CRUD 리포지토리를 정의해보자

~~~java
@Repository
interface BookJpaRepository extends CrudRepository<Book, Integer> {
    // 메서드 이름에 기반한 쿼리 생성
    Iterable<Book> findByIdBetween(int lower, int upper);
    
    // JPQL 쿼리를 사용해 쿼리 수행
    @Query("SELECT b FROM Book b WHERE LENGTH(b.title) = " + "(SELECT MIN(LENGTH(b2.title)) FROM Book b2)")
    Iterable<Book> findShortestTitle();
}
~~~

- JDBC 드라이버, 스프링 부트 의존성, Book 엔티티 클래스 및 BookJpaRepository 인터페이스만 있으면 스프링 데이터 JPA 등에 기반한 매우 다양한 영속성 계층 지원이 가능!

#### 스프링 데이터 JPA를 리액티브하게 만들기

- 향후 몇년 동안 가능성은 희박하다고 함..

#### Spring Data NoSQL

- 스프링 데이터 JPA와 스프링 데이터 JDBC는 둘 다 관계형 데이터베이스와 JDBC 드라이버를 연결하기 위한 훌륭한 솔루션이다.
- 하지만 대부분 NoSQL 데이터베이스는 이를 지원하지 않는다.
- 이를 위해 스프링 데이터 프로젝트에는 **널리 사용되는 NoSQL 데이터베이스를 목표로 하는 몇 개의 개별 모듈**이 있음

~~~java
// @Entity 대신 @Document 사용
// MongoDB에서만 해당되며, 지정한 데이터베이스 컬렉션을 참조할 수 있게 해줌
@Document(collection = "book") 
public class Book {
  @Id
  private ObjectId id;
  
  @Indexed // 인덱스 사용
  private String title;
  
  @Indexed
  private List<String> authors;
  
  @Field("pubYear") // 데이터베이스의 필드 이름과 다른 엔티티명을 사용할 수 있음
  private int publishingYear;
}

// JSON RESULT
{
	"_id" : ObjectId("5b1c0908eb696eddfadc0b1b"),
  	"title" : "The Expanse: Leviathan Wakes", "pubYear" : 2011,
	"authors":[
		"Daniel Abraham",
		"Ty Franck" 
  	],
    // Object-Document Mapping 되는 자바 클래스를 설명하는 _class 필드를 추가한다.
	"_class" : "org.rpis.chapters.chapter_07.mongo_repo.Book" 
}
~~~

~~~java
//MongoRepository는 CrudRepository를 상속
@Repository
public interface BookSpringDataMongoRepository extends MongoRepository<Book, Integer> {
  //명명에 맞는 로직 수행
  Iterable<Book> findByAuthorsOrderByPublishingYearDesc(String... authors);
  
  // MongoDB 쿼리 작성 가능
  // 저자가 둘 이상인 책 검색
  @Query("{ 'authors.1': {$exists: true} }")
  Iterable<Book> booksWithFewAuthors();
}
~~~

- 결론적으로 스프링 프레임워크로 NoSQL 데이터베이스를 리액티브 방식으로 사용하려면 **전체 기본 인프라가 리액티브 또는 비동기 API를 제공해야 한다.**
  - NoSQL DB는 비교적 최근에 출현해 동기식 블로킹 API에 크게 의존하지 않음
  - 결과적으로 JDBC 드라이버를 사용하는 **RDB보다 NoSQL DB를 리액티브하게 사용하는 것이 더 쉽다.**

- 현재 스프링 데이터에는 몇 가지 리액티브 데이터 커넥터가 있으며, MongoDB도 그 중 하나

#### 동기 모델의 한계

- JDBC, JPA, Hibernate, 스프링 데이터 JPA 등등 이들은 본질적으로 **동기식이며 블로킹**이다.

- 데이터베이스에 쿼리를 발행하는 자바 스레드는 첫 번째 데이터가 도착하거나 시간 초과가 발생할 때까지 블로킹될 것이며, 이는 리액티브 응용 프로그램의 관점에서 보면 상당한 낭비이다.

  - 물론 I/O 요청이 HTTP이든 데이터베이스 요청이든 블로킹 방법으로 만드는 것은 낭비이다.

- JDBC 기반 통신은 일반적으로 커넥션 풀을 사용해 쿼리를 병렬로 실행한다.

- 반대로 HTTP2 프로토콜을 사용하면 동일한 TCP 연결을 사용해 여러 리소스를 동시에 보내고 받을 수 있다.?

- 이 방법은 TCP 소켓의 수를 줄이고 그림과 같이 클라이언트와 서버 모두에 대해 더 큰 동시성을 허용함

  <img src="./image/그림 7.15 일반적인 데이터베이스 통신과 멀티플렉싱을 지원하는 통신 프로토콜 .png" alt="그림 7.15 일반적인 데이터베이스 통신과 멀티플렉싱을 지원하는 통신 프로토콜 " style="zoom:40%;" />

- HTTP2와 같이 멀티플렉싱을 활용하기 위해 JDBC 아래에 통신 레이어를 구현하는 것도 가능하지만, 여전히 JDBC 이전 계층에서 동작하는 코드는 동기적이고 블로킹된다.

- 데이터베이스가 멀티플렉싱을 활용할 수 있는 비동기 논블로킹 드라이버를 제공하더라도 JDBC, JPA 또는 스프링 데이터 JPA를 사용해서 최대한의 성능을 얻을 수는 없다..

  - 따라서 **완전히 리액티브한 애플리케이션을 구현하려면 동기식 기술을 포기하고 리액티브를 사용해 API를 만들어야 한다!**

- 물론 동기 모델이 나쁜 것은 아니다. 리액티브 분야에 적합하지 않을 뿐이다.

### 동기 모델의 장점

- 블로킹 웹 응용 프로그램을 구축할 때는 매우 유용하다

  - JDBC는 응용 프로그램과 데이터베이스 간의 클라이언트 - 서버 통신의 복잡한 부분을 라이브러리 내에서 구현하고 외부로 노출시키지 않는다.
  - 스프링 데이터 JDBC, JPA는 쿼리 번역 및 트랜잭션 관리의 엄청난 복잡성을 내부적으로 구현했다.

- 테스트가 쉬움

- 배압 지원이 필요하지 않음

- 로컬 및 분산 트랜잭션에 대한 탁월한 지원을 제공

- 유일한 단점? 실행 시점에 블로킹 된다는 것

- 추가로 리액티브 패러다임(네티, 리액터, 웹플럭스)으로 구축한 리액티브 웹 응용 프로그램과는 호환되지 않음.. 

  

- 이제 스프링 데이터 리포지토리의 다양성을 손상시키지 않으면서 **스프링 데이터의 리액티브 커넥터가 어떻게 고성능을 약속하는지** 확인해보자

### 스프링 데이터로 리액티브하게 데이터 접근하기

- 우리는 엔티티 컬렉션을 지원하는 리포지토리가 아닌 **리액티브한 엔티티 스트림으로 동작하는 리포지토리**가 필요함

- 리액티브 Publisher<Entity>를 이용해서 동작이 가능해야 하며, 리액티브 타입으로 반환이 가능해야 함

- 개발자들은 데이터베이스를 쿼리할 때 스프링 웹플럭스 모듈의 WebClient와 비슷한 방식으로 데이터 리포지토리를 사용하기를 원할 것이다

  ~~~java
  // webclient example
  Webclient.create("http://DB-SERVER/voc/") 
    				.get() 
    				.uri("/voc/(id)", userId)    
    				.retrieve() 
  				.bodyToMono(User.class)
    				.map(...)
    				.subscribe();
  ~~~

- 스프링 데이터 Commons 모듈에는 이러한 동작을 제공하는 **ReactiveCrudRepository 인터페이스**가 포함돼 있다.

- 리액티브 데이터 액세스 계층을 사용할 때 이점

  1. 효과적인 스레드 관리 - I/O 작업이 블로킹되지 않음

  2. 첫 번째 쿼리 결과에 대한 짧아진 대기 시간 - 쿼리가 끝나기 전에도 사용할 수 있음

  3. 낮은 메모리 사용량 - 쿼리 처리 시 버퍼링해야 할 데이터가 적기 때문에 유용

  4. 배압 전파 - 데이터를 소비하는 데이터베이스의 능력을 알려줄 수 있음

  5. 하나의 커넥션 공유 - 다른 스레드에서 쿼리와 데이터 처리 작업을 보낼 수 있음

  6. 연쇄형 API를 사용하는 리액티브 코드와 부드럽게 결합되는 영속성 계층

- 스프링 부트 애플리케이션에서 리액티브 영속성을 사용하려면 리액티브 커넥터가 있는 DB 중 하나를 사용해야 한다.

  - MongoDB, Cassandra, Redis, Couchbase 가 리액티브 연결을 제공한다.

- MongoDB를 이용해 리액티브 CRUD 리포지토리가 어떻게 작동하는지 살펴보자.

#### MongoDB 리액티브 리포지토리

- https://docs.spring.io/spring-data/mongodb/docs/current/api/org/springframework/data/mongodb/repository/ReactiveMongoRepository.html
- MongoDB 오브젝트 - 도큐먼트 매핑과 관련된 애노테이션은 동기식 MongoDB 모듈과 리액티브 MongoDB 모듈에서 동일하게 사용가능하나 **리포지토리는 리액티브 타입으로 대체**해야 함

~~~java
// ReactiveMongoRepository : 리액티브 커넥터의 공용 인터페이스인 ReactiveCrudRepository 상속
// ReactiveCrudRepository : CrudRepository 인터페이스에 대한 리액티브 구현
public interface ReactiveSpringDataMongoBookRepository extends ReactiveMongoRepository<Book, Integer> {
    //쿼리 자동 생성
    @Meta(maxScanDocuments = 3) // 쿼리 튜닝 기능. 최대 도큐먼트 수를 뜻하는 듯하나 deprecated됨
    Flux<Book> findByAuthorsOrderByPublishingYearDesc(Flux<String> authors);
    
    // 직접 작성한 MongoDB 쿼리
    @Query("{ 'authors.1': { $exists: true } }")
    Flux<Book> booksWithFewAuthors();
}
~~~

- 페이징 처리는 지원하지 않음.
- 리액티브 리포지토리를 사용해 MongoDB에 몇 권의 책을 추가하는 예제

~~~java
@Autowired
private ReactiveSpringDataMongoBookRepository rxBookRepository;

Flux<Book> books = Flux.just(
	new Book("The Martian", 2011, "Andy Weir"),
	new Book("Blue Mars", 1996, "Kim Stanley Robinson")
);

rxBookRepository
    .saveAll(books) // 엔티티를 저장(실제 구독 전에는 저장되지 않음)
    .then()
    .doOnSuccess(ignore -> log.info("Books saved in DB")) // 완료되면 로그 출력
    .subscribe();
~~~

- 리액티브 스트림을 사용해 MongoDB를 쿼리하는 예제

~~~java
private void reportResults(String message, Flux<Book> books) {
    books
        .map(Book::toString)
        .reduce( // 모든 책의 문자열을 하나의 메시지로 수집
    		new StringBuilder(), (sb, b) -> sb.append(" - ")
        									.append(b)
        									.append("\n"))
        .doOnNext(sb -> log.info(message + "\n{}", sb))
        .subscribe();
}
~~~

~~~java
Flux<Book> allBooks = rxBookRepository.findAll();
reportResults("All books in DB:", allBooks);

Flux<Book> andyWeirBooks = rxBookRepository.findByAuthorsOrderByPublishingYearDesc(Mono.just("Andy Weir"));
reportResults("All books by Andy Weir: ", andyWeirBooks);
~~~

#### 리포지토리 동작 조합하기

- 책의 제목만 알고 있는 상태에서 책의 출판 연도를 업데이트해야 하는 상황
  1. 원하는 책 인스턴스를 찾고
  2. 게시 연도를 업데이트
  3. 책을 데이터베이스에 저장

~~~java
// 유스케이스를 복잡하게 만들기 위해 제목, 연도 값이 약간의 지연을 두고 비동기적으로 검색돼 전달된다고 가정
public Mono<Book> updatedBookYearByTitle(Mono<String> title, Mono<Integer> newPublishingYear)
~~~

- 위 함수의 구현 동작 확인을 위한 테스트 시나리오를 만들어 보자.

~~~java
Instant start = now(); // 시작 시간 저장
Mono<String> title = Mono.delay(Duration.ofSeconds(1))
    	.thenReturn("Artemis")
    	.doOnSubscribe(s -> log.info("Subscribed for title"))
    	.doOnNext(t -> log.info("Book title resolved: {}", t));

Mono<Integer> publishingYear = Mono.delay(Duration.ofSeconds(2))
    	.thenReturn(2017)
    	.doOnSubscribe(s -> log.info("Subscribed for publishing year"))
    	.doOnNext(t -> log.info("New publishing year resolved: {}", t));

updatedBookYearByTitle(title, publishingYear)
    .doOnNext(b -> log.info("Publishing year updated for book: {}", b))
    .hasElement() // onNext 이벤트가 있는지 확인
    .doOnSuccess(status -> log.info("Updated finished {}, took: {}", 
                                    status ? "successfully" : "unsuccessfully",
                                   between(start, now())))
    .subscribe(); // 리액티브 워크플로 시작
~~~

- 첫번째 테스트

~~~java
private Mono<Book> updatedBookYearByTitle(Mono<String> title, Mono<Integer> newPublishingYear) {
    return rxBookRepository.findOneByTitle(title)
        .flatMap(book -> newPublishingYear
                .flatMap(year -> {
                    book.setPublishingYear(year);
                    return rxBookRepository.save(book);
                }))
}

Subscribed for title.
Book title resolved: Artemis
Subscribed for publishing year
New publishing year resolved: 2017
Publishing year updated for book: Book(publishingYear=2017...
Updated finished successfully, took: PT3.027S
~~~

- 문제점? 제목을 받은 후에야 새로운 출판 연도를 구독함 (blocking) - 3초 넘게 걸림
- 검색 프로세스를 즉시 시작하려면 워크 플로 시작 시 두 스트림을 모두 구독해야 한다.
- 2번째 테스트 - zip 메서드 사용

~~~java
private Mono<Book> updatedBookYearByTitle(Mono<String> title, Mono<Integer> newPublishingYear) {
    return Mono.zip(title, newPublishingYear) 
        .flatMap((Tuple2<String, Integer> data) -> {
            String titleVal = data.getT1();
            Integer yearVal = data.getT2();
            return rxBookRepository
                .findOneByTitle(title)
                .flatMap(book -> {
                         book.setPublishingYear(year);
                         return rxBookRepository.save(book);
                }); 
        });
}

Subscribed for title
Subscribed for publishing year
Book title resolved: Artemis
New publishing year resolved: 2017
Publishing year updated for the book: Book(publishingYear=2017...
Updated finished successfully, took: PT2.032S
~~~

- 첫 번째 방법보다는 빠르지만, Tuple2 타입을 사용하기 때문에 추가 코드 라인과 변환 작업이 필요함
- **리액터 애드온** 모듈을 추가하는 세번째 방법

~~~java
private Mono<Book> updatedBookYearByTitle(Mono<String> title, Mono<Integer> newPublishingYear) {
    return Mono.zip(title, newPublishingYear) 
        .flatMap(
        TupleUtils.function((titleValue, yearValue) -> 
                            rxBookRepository
                                .findOneByTitle(title)
                                .flatMap(book -> {
                                     book.setPublishingYear(year);
                                     return rxBookRepository.save(book);
                				})
                           )
    	);
}
~~~

- 세번째 테스트에서는 제목 및 새로운 발행 연도를 **모두 받은 후**에만 데이터베이스에 책을 검색하라는 명령을 보냄
- 네 번째 테스트에서는 게시 연도 요청이 아직 진행 중이더라도 제목이 이미 있는 경우 책 검색을 시작할 수 있음

~~~java
//어떤 스레드도 블로킹되지 않음
private Mono<Book> updatedBookYearByTitle(Mono<String> title, Mono<Integer> newPublishingYear) {
    return Mono.zip(newPublishingYear, rxBookRepository.findOneByTitle(title)) 
        .flatMap(function((yearValue, bookValue) -> {
            bookValue.setPublishingYear(yearValue);
            return rxBookRepository.save(bookValue);
        }));
}
~~~

- 이 실습의 요점은 리액티브 스트림과 리액터 프로젝트의 다양한 API를 이용해 데이터 영속성 계층을 포함하는 다양한 비동기 워크플로를 쉽게 구축할 수 있다는 것
- 하지만 리액티브 파이프라인을 작성할 때 리액티브 연산자의 다른 조합을 고려하고 가장 먼저 생각나는 옵션을 선택하지 말고 **비즈니스 요청에 가장 적합한 옵션**을 선택하자..!

#### 리액티브 리포지토리 동작 원리

- Reactive Repository의 동작 원리에 대해 살펴보자.
- 스프링 데이터 리액티브 리포지토리는 데이터베이스 드라이버의 기능을 사용해 작동한다.
  - 드라이버에는 리액티브 스트림 호환 드라이버나 비동기 드라이버가 있을 수 있으며, 드라이버는 리액티브 API로 래핑할 수 있다
- 리액티브 MongoDB 리포지토리가 리액티브 스트림 호환 MongoDB 드라이버를 사용하는 방법과 리액티브 Cassandra 리포지토리가 비동기식 드라이버를 어떻게 이용해 동작하는지를 살펴보자.
- ReactiveMongoRepository 인터페이스는 ReactiveSortingRepository 및 ReactiveQueryByExampleExecutor와 같은 보다 일반적인 인터페이스를 상속함.
  - ReactiveQueryByExampleExecutor ➡️ QBE 언어로 쿼리 실행 가능
  - ReactiveSortingRepository ➡️ 쿼리 결과를 정렬할 수 있는 findAll 메서드 사용 가능
- 많은 리액티브 커넥터들이 **ReactiveCrudRepository** 인터페이스를 사용
  - 이는 엔티티를 저장 및 검색, 삭제하는 메서드를 가지고 있음.
  - Mono<T> save(T entity) : 엔티티를 저장한 다음 저장한 엔티티를 반환해 이후 작업에 사용
  - Mono<T> findById(ID id) : 엔티티의 id를 매개변수로 하고 Mono로 래핑된 결과를 반환 
  - Mono<T> findAllById : Iterable<ID> 컬렉션 형식의 ID를 매개변수로 받을 수도 있고, Publisher<ID> 타입을 매개변수로 받을 수도 있다.
    - findAllById(Iterable<ID> ids)
    - findAllById(org.reactivestreams.Publisher<ID> idStream)
- ReactiveCrudRepository 와 CrudRepository의 차이점
  - ReactiveCrudRepository가 **페이징 처리를 지원하지 않으며 트랜잭션 동작을 허용하지 않음**

#### 페이징 지원

- 스프링 데이터 팀은 의도적으로 페이징을 지원하지 않기로 했다는 점을 알아두자.

- 페이징을 위해선 한 페이지의 레코드 수? 그리고 모든 레코드의 수를 쿼리해야 함 ➡️ 리액티브 논블로킹 패러다임에 적합하지 않음

- 그러나 다음과 같이 Pageable 객체를 리포지토리에 전달해 데이터 청크를 가져올 수 있다.

  ~~~java
  public interface ReactiveBookRepository extends ReactiveSortingRepository<Book, Long> {
    Flux<Book> findByAuthor(String author, Pageable pageable);
  }
  ~~~

- 한 페이지에 다섯 개씩 데이터를 요청한다고 했을 때 두 번째 페이지 요청하는 예시

  ~~~java
  // 1 => 두 번째 페이지, 5 => 데이터 갯수
  Flux<Book> result = reactiveBookRepository.findByAuthor('Andy Weir', PageRequest.of(1,5));
  ~~~

#### ReactiveMongoRepository 세부 구현

- findAllById(Publisher<ID> id) 메서드 구현을 살펴보자.

  ~~~java
  public Flux<T> findAllById(Publisher<ID> ids) {
    return Flux.from(ids).buffer() // 모든 ID 수집
      .flatMap(this::findAllById); // ?? findById여야 하는거 아닌가
  }
  ~~~

- insert(Iterable<S> entities) 메서드 : 엔티티를 일괄 작업으로 등록

- insert(Publisher<S> entities) 메서드

  ~~~java
  public <S extends T> Flux<S> insert(Publisher<S> entities) {
    return Flux.from(entities)
      .flatMap(entity -> mongoOperations.insert(entity, ...));
  }
  ~~~

- saveAll : Publisher가 엔티티마다 쿼리를 실행하는 메서드를 재정의
- deleteAll : 항상 엔티티마다 쿼리를 생성
- 위에서 봤듯이, 동일한 메서드를 재정의하는 방법에 따라 다른 방식으로 동작할 수 있으며 서로 다른 수의 데이터베이스 쿼리를 생성할 수 있다.
- ReactiveCrudRepository를 사용하는 경우 실제 구현체가 런타임에 생성되기 때문에 실제 쿼리를 보는 것이 더 어려움
  - 그러나 이 경우에도 쿼리 생성 방법은 동기식 CrudRepository와 비슷함
- 그 외에도..
  - RepositoryFactorySupport : ReactiveCrudRepository에 대한 적절한 프록시 생성
  - ReactiveStringBasedMongoQuery : 메서드에 @Query 애노테이션을 붙여서 쿼리를 생성하는 데 사용됨
  - ReactivePartTreeMongoQuery : 메서드 이름 규칙을 기반으로 쿼리를 생성하는 데 사용됨
  - ReactiveMongoTemplate : 로깅 레벨을 DEBUG로 설정해서 MongoDB로 보내지는 모든 쿼리를 추적할 수 있음

#### ReactiveMongoTemplate 사용하기

- ReactiveMongoTemplate이 리액티브 **리포지토리의 빌딩 블록**으로 사용되기는 하지만, 이 클래스 자체에도 매우 다양한 메서드가 있으며, **때로는** **리포지토리를 이용하는 것보다 데이터베이스 작업을 더 효율적으로 수행**할 수 있다.

- ReactiveMongoTemplate으로 정규 표현식을 사용해 제목별로 책을 찾는 간단한 서비스

  - ReactiveMongoTemplate은 ReactiveMongoOperations 인터페이스를 구현하며 MongoDB 데이터 소스가 제대로 설정됐다면 스프링 컨텍스트 내에 포함됨

  ~~~java
  public class RxMongoTemplateQueryService {
    private final ReactiveMongoOperations mongoOperations;
    // ~~~
    
    public Flux<Book> findBooksByTitle(String titleRegExp) {
      Query query = Query.query(new Criteria("title").regex(titleRegExp))
        .limit(100);
      return mongoOperations.find(query, Book.class, "book"); // query 결과를 Book 클래스 엔티티에 매핑
    }
  }
  ~~~

#### Mongo DB 리액티브 드라이버 사용하기

- 스프링 데이터의 MongoDB 연결은 MongoDB 리액티브 스트림 자바 드라이버를 기반으로 한다.
  - 이 드라이버는 Non-Blocking BackPressure로 비동기 스트림 처리를 제공
- 리액티브 드라이버는 MongoDB 비동기 자바 드라이버 위에 구축됨.
- 물론 ReactiveMongoTemplate이 제공하는 것보다 쿼리 프로세스를 더 많이 제어해야 하는 경우에는 리액티브 드라이버를 직접 사용할 수도 있음
  - 이에 대한 자세 정보는 책 참고..
- 하지만 리액티브 스트림으로 작업하는 것이 훨씬 편리하고 배압을 수동으로 처리할 필요가 없음
- 최종으로, 리액티브 MongoDB 리포지토리에 필요한 모든 추상화 계층을 확인해보자.

<img src="/Users/seongjayong/Learning/book-spring-reactive/image/그림 7.16 스프링 데이터의 리액티브 MongoDB 스택.png" alt="그림 7.16 스프링 데이터의 리액티브 MongoDB 스택" style="zoom:50%;" />

#### Cassandra 비동기 드라이버 사용하기

- 리액티브 Cassandra 리포지토리가 비동기 드라이버를 어떻게 사용하는지 살펴보자.
- https://docs.spring.io/spring-data/cassandra/docs/current/api/org/springframework/data/cassandra/repository/ReactiveCassandraRepository.html
- All Superinterfaces: `ReactiveCrudRepository<T,ID>`, `Repository<T,ID>`
- All Known Implementing Classes: `SimpleReactiveCassandraRepository`
- 저수준 작업을 위해 ReactiveCassandraOperations 인터페이스를 사용함
- ReactiveCassandraTemplete은 응용 프로그램에서 직접 사용 가능
- 외에 도움을 주는 클래스들이 있음.. 자세한 내용은 책 참조
- 리액티브 스프링 데이터 Cassandra 모듈의 내부 아키텍처

<img src="/Users/seongjayong/Learning/book-spring-reactive/image/그림 7.17 스프링 데이터의 리액티브 Cassandra 스택.png" alt="그림 7.17 스프링 데이터의 리액티브 Cassandra 스택" style="zoom:40%;" />

#### 리액티브 트랜잭션

- 트랜잭션 : 원자 단위로 수행돼야 하는 다수의 논리 연산 경계를 정의하는 데이터베이스의 표현
- 트랜잭션에는 **트랜잭션 초기화 시점**, **트랜잭션 객체와 관련된 작업이 진행되는 시점**, 그리고 **최종 결정 시점**이 있다.
  - 최종 결정 시점에 클라이언트와 데이터베이스느 트랜잭션이 성공적을 커밋 또는 롤백될지를 결정함.

- 동기식 환경에서 트랜잭션은 ThreadLocal에 보관되는데, 리액티브 플로에서 이를 사용하기에는 적합하지 않음.
- 이에, 리액티브 플로에서는 리액터 프로젝트의 **리액터 컨텍스트**에서 이런 작업이 매우 적합함.

#### MongoDB 4의 리액티브 트랜잭션

- MongoDB는 **다중 도큐먼트 트랜잭션(multi-document transaction)**을 지원함.

  - 리액티브 트랜잭션을 구현하는 MongoDB의 새로운 기능
  - 많은 작업, 문서 및 컬렉션에 대해 전체를 커밋하거나 롤백할 수 있음
  - 데이터 뷰에 대한 글로벌한 일관성을 보장함

- MongoDB에 문서를 저장하는 데 리액티브 트랜잭션을 사용할 수 있음을 확인해보자.

- 계정 간 돈을 이체하는 서비스를 구현한다고 하자.

  - 트랜잭션이 없으면 계좌 보유 잔금보다 더 많은 돈을 송금할 수도 있다
  - 사용자는 돈을 여러번 얻을 수도 있다

- 트랜잭션을 통해 일관성을 보장해 보자.

  ~~~java
  @Document(collection = "wallet")
  public class Wallet {
    @Id
    private ObjectId id; // ObjectId 클래스는 엔티티 ID로 사용됨
    private String owner;
    private int balance;
    
    public boolean hasEnoughFunds(int amount) {
      return balance >= amount;
    }
    
    public void withdraw(int amount) {
      if (!hasEnoughFunds(amount)) {
        throw new IllegalStateException("Not enough funds!");
      }
      this.balance = this.balance - amount;
    }
    
    public void deposit(int amount) {
      this.balance =. his.balance + amount;
    }
  }
  ~~~

- DB에서 잔액을 저장하고 로드하기 위한 리포지토리 선언

  ~~~java
  public interface WalletRepository extends ReactiveMongoRepository<Wallet, ObjectId> {
    Mono<Wallet> findByOwner(Mono<String> owner);
  }
  ~~~

- WalletService 인터페이스

  ~~~java
  public interface WalletService {
    // return을 Mono<TxResult>로 받아 결과를 알 수 있음
    Mono<TxResult> transferMoney(Mono<String> fromOwner, Mono<String> toOwner, Mono<Integer> amount);
    // 시스템의 모든 계좌에 대한 집계용 -> 무결성 검사
    Mono<Statistics> reportAllWallets();
    
    enum TxResult {
      SUCCESS, NOT_ENOUGH_FUNDS, TX_CONFLICT
    }
    
    class Statistics {
      // class 구현 코드는 생략
    }
  }
  ~~~

- 단위 테스트 작성

  ~~~java
  public Mono<OperationStats> runSimulation() {
    return Flux.range(0, iterations)
      .flatMap(i -> Mono
              .delay(Duration.ofMillis(rnd.nextInt(10)))
              .publishOn(simulationScheduler) // 트랜잭션 실행
              .flatMap(_i -> {
                String fromOwner = randomOwner();
                String toOwner = randomOwnerExcept(fromOwner);
                int amount = randomTransferAmount();
                return walletService.transferMoney(
                	Mono.just(fromOwner),
                  Mono.just(toOwner),
                  Mono.just(amount)
                );
              }))
      .reduce(OperationStats.start(), OperationStats::countTxResult);
  }
  ~~~

- 이제 MongoDB 4 및 스프링 데이터에서 제공하는 **리액티브 트랜잭션**을 사용해 WalletService 구현

  ~~~java
  public class TransactionWalletService implements WalletService {
    private final REactiveMongoTemplate mongoTemplate;
    
    @Override
    Mono<TxResult> transferMoney(Mono<String> fromOwner, Mono<String> toOwner, Mono<Integer> requestAmount) {
      return Mono.zip(fromOwner, toOwner, requestAmount)
        .flatMap(function((from, to, amount) -> {
          return doTransferMoney(from, to, amount) // 돈 송금
            .retryBackoff(
          20, Duration.ofMillis(1), Duration.ofMillist(500), 0.1)
            .onErrorReturn(TxResult.c);
        }));
    }
    
    private Mono<TxResult> doTransferMoney(String from, String to, Integer amount) {
      // inTransaction -> 새 트랜잭션을 시작해 이를 컨텍스트에 추가
      return mongoTemplate.inTransaction().execute(session -> 
                                                   //송금인 검색
                                                  session.findOne(queryForOwner(from), Wallet.class)
                                                   // 수취인 검색
                                                  .flatMap(fromWallet -> session.findOne(queryForOwner(to), Wallet.class)
                                                          .flatMap(toWallet -> {
                                                            if(fromWallet.hasEnoughFunds(amount)) { // 보낼 돈이 있는지 확인
                                                              fromWallet.withdraw(amount);
                                                              toWallet.deposit(amount);
                                                              return session.save(fromWallet)
                                                                .then(session.save(toWallet))
                                                                .then(Mono.just(TxResult.SUCCESS));
                                                            } else {
                                                              return Mono.just(TxResult.NOT_ENOUGH_FUNDS);
                                                            }
                                                          })))
                                          .onErrorResume(e -> Mono.error(new RuntimeException("Conflict")))
                                          .last();
    }
    
    private Query queryForOwner(String owner) {
      return Query.query(new Criteria("owner").is(owner));
    }
  }
  ~~~

  - 트랜잭션에서 정확한 세션을 참조하는 것은 리액터 컨텍스트를 사용해 구현함.
    - ReactiveMongoContext.getSession() 헬퍼? 메서드를 사용하면 세션 인스턴스를 받아올 수 있음

- 이런 방식으로 MongoDB와의 리액티브 트랜잭션을 적용하여 **시스템 무결성**을 달성할 수 있다
- 추후 리액티브 트랜잭션이 더 발전하기를 기다리는 상태..

#### Saga 패턴을 사용한 분산 트랜잭션

- 스프링 데이터가 MongoDB 4 에 대해서만 리액티브 트랜잭션을 지원하고 이것이 자바 트랜잭션 API(Java Transaction API)와 호환되지 않기 때문에 리액티브 마이크로서비스 내에서 분산 트랜잭션을 구현할 수 있는 유일한 옾션은 **SAGA 패턴**뿐임.
- 또한 SAGA 패턴은 분산 트랜잭션을 필요로 하는 다른 패턴보다 리액티브 시스템에 더 잘 어울리고 확장성도 우수함.

### 스프링 데이터 리액티브 커넥터

- 스프링 데이터 2.1에는 MongoDB, Cassandra, Couchbase 및 Redis 총 4가지 NoSQL 데이터에비스에 대한 **데이터베이스 커넥터**가 포함돼 있다.
  - 데이터베이스 커넥터 : 프로그램과 DB를 연결해주는 프로그램
- 각 리액티브 커넥터의 핵심적인 특징을 알아보자.

#### MongoDB 리액티브 커넥터

- 스프링 데이터는 MongoDB를 훌륭하게 지원
- ReactiveMongoRepository 인터페이스는 기본적인 리포지토리 스펙을 따름
  - 또한 @Query, @Meta 애노테이션을 사용해 사용자가 직접 쿼리 작성도 가능
- 커서 사용 가능
  - 모든 결과를 처리하면 쿼리 커서를 자동으로 닫으나, 고정 크기를 가지며 처리량이 많은 작업을 지원하기 위한 캡드 컬렉션이 있음
  - 캡드 컬랙션의 동작원리는 원형 버퍼와 비슷함
  - ReactiveMongoRepository에서 메서드에 @Tailable 애노테이션을 추가하면 메서드는 Flux<Entity> 타입의 커서를 반환
- ReactiveMongoTemplate을 이용해 다중 도큐먼트 트랜잭션 가능

#### Cassandra 리액티브 커넥터

- @Query 애노테이션을 이용하면 CQL3 쿼리를 수동으로 작성 가능
- @Concistency 애노테이션을 이용하면 쿼리에 적용된 일관성 레벨을 원하는 대로 직접 설정할 수 있음

#### Couchbase 리액티브 커넥터

- 책 참조..

#### Redis 리액티브 커넥터

- 다른 리액티브 커넥터와 달리 Redis 커넥터는 리액티브 리포지토리를 제공하지 않음.
- 객체 저장, 검색 등 Redis 데이터를 관리하는 일반적인 동작 외에도, 이 템플릿은 Pub-Sub 방식의 채널 구독을 지원

#### 제약 사항과 기대되는 개선 사항

- 대중적인 데이터베이스에 대한 리액티브 드라이버가 부족
- 부족한 리액티브 JPA - 일반 JPA가 권장하는 엔티티를 다루는 방식을 리액티브에서 지원하지 못함
- 데이터 액세스를 위한 언어 수준의 리액티브 API가 부족함
- 이에, **자바에서 데이터 액세스를 위한 언어 수준 API**를 지원하기 위해 활발히 작업 진행 중이며 **R2DBC**가 잠재적인 대안!!

#### ADBA

- 없어짐.

#### R2DBC(Reactive Relational Database Connectivity)

- 리액티브 데이터베이스 API를 만들기 위한 프로토타입

- 스프링 데이터 팀은 R2DBC를 선도하고 있으며, 리액티브 애플리케이션 내에서 사용하고자 개발 중.

- R2DBC의 목표는 배압 지원 기능이 있는 리액티브 데이터베이스 액세스 API를 정의하는 것

- R2DBC 프로젝트 구성

  - R2DBC 서비스 제공자 인터페이스(SPI) : 드라이버 구현을 위한 최소한의 API 정의.
  - R2DBC 클라이언트 : 사용자 요청을 SPI 레벨로 변환하는 사용자 친화적인 API 및 헬퍼 클래스
    - 별도의 추상화 레이어를 제공함으로써 R2DBC를 직접 사용할 때 약간의 편의를 제공
  - R2DBC PostgreSQL : PostgreSQL용 R2DBC 드라이버를 제공.

  ~~~java
  // 커넥션 팩토리 설정
  PostgresqlConnectionFactory pgConnectionFactory = PostgresqlConnectionConfiguration.builder()
    .host("<host>")
    .database("<database>")
    .username("<username>")
    .password("<password>")
    .build();
  // R2dbc 클래스의 인스턴스 생성
  R2dbc r2dbc = new R2dbc(pgConnectionFactory);
  // 트랜잭션 생성
  r2dbc.inTransaction(handle -> 
                      handle
                      // execute 메서드는 영향을 받은 행의 수를 반환
                      .execute("insert into book (id, title, publishing_year) " + 
                              "values ($1, $2, $3)",
                              20, "The Sands of Mars", 1951)
                     		.doOnNext(n -> log.info("{} rows inserted", n))
                     ).thenMany(r2dbc.inTransaction(handle) ->
                               handle.select("SELECT title FROM book")
                               .mapResult(result ->
                                         result.map((row, rowMetadata) ->
                                                   row.get("title", String.class)))))
    									.subscribe(elem -> log.info(" - Title: {}", elem));
  ~~~

- https://techblog.woowahan.com/10795/

#### 스프링 데이터 R2DBC와 함께 R2DBC 사용하기

- 스프링 데이터 팀 역시 R2DBC 위에 ReactiveCrudRepository 인터페이스를 구현하는 방식을 원하지만, R2DBC가 적용된 모듈은 Spring Data R2DBC라는 자체 모듈로 패키징 될 것임.

- PostgreSQL을 위한 ReactiveCrueRepository 정의

  - BookRepository 인터페이스를 직접 만들어주어야 함.

  ~~~java
  public interface BookRepository extends ReactiveCrudRepository<Book, Integer> {
    @Query("SELECT * FROM book WHERE publishing_year = " + "(SELECT MAX(publishing_year) FROM book)")
    Flux<Book> findTheLatestBooks();
  }
  ~~~

- 이러한 관계형 데이터베이스에 대한 리액티브 액세스가 곧 현실화 될 것이다...!!

### 동기식 리포지토리를 리액티브 스타일로 변경하기

- 스프링 데이터는 몇몇 NoSQL 데이터베이스에 대해 리액티브 커넥터를 제공하지만, 리액티브 애플리케이션은 리액티브 커넥터가 없는 데이터베이스를 쿼리해야 하는 경우가 있음.
- 관계형 데이터베이스에 요청을 수시로 날리는 리액티브 마이크로 서비스를 구현해야 한다고 가정하자.
  - 이 경우 리액티브 API 안에 블로킹 요청을 숨기는 리액티브 어댑터를 만드는 것이 유일한 옵션
  - 이에 **블로킹 통신**을 **리액티브 API로 래핑**하는 것이 필요

- 적절한 블로킹 API를 선택할 때 선택 가능한 몇 가지 옵션이 있다.

#### rxjava2-jdbc 라이브러리 사용하기

- 위 라이브러리는 리액티브 **응용 프로그램을 블로킹하지 않으면서 JDBC 드라이버를 Wrapping**하기 위해 개발됨

- RxJava 2를 기반으로 하며 전용 스레드 풀과 논블로킹 커넥션 풀 개념을 사용

  ~~~java
  @Query("select id, title, publishing_year" + "from book order by publishing_year")
  public interface Book {
    @Column String id();
    @Column String title();
    @Column Integer publishing_year();
  }
  //왜 ()..?
  ~~~

- RxBookRepository 클래스 구현

  ~~~java
  public class RxBookRepository {
  	private static final String SELECT_BY_YEAR_BETWEEN = 
      "select * from book where publishing_year >= :from and publishing_year <= :to";
    private final String url = "jdbc:h2:mem:db";
    private final int poolSize = 25;
  	private final Database database = Database.from(url, poolSize);
    
    public Flowable<Book> findByYearBetween(Single<Integer> from, Single<Integer> to) {
      return Single
        .zip(fro, to, Tuple2::new)
        .flatMapPublisher(tuple -> database
                          .select(SELECT_BY_YEAR_BETWEEN)
  												.parameter("from", tuple._1()) 
                          .parameter("to", tuple._2()) 
                          .autoMap(Book.class));
    }
  }
  ~~~

- 대부분의 JDBC 드라이버를 지원하고, 트랜잭션도 일부 지원

- 하지만 아직까지 신생 라이브러리고, 모든 SQL 쿼리를 직접 작성해야 함..

#### 동기식 CrudRepository 래핑하기

- CrudRepository를 리액티브 응용 프로그램에서 직접 사용할 수 없기에 **Repository 수준에서 리액티브 어댑터**가 필요하다.
- 리포지토리 수준에서 리액티브 어댑터를 직접 만드는 것은 어려운 일이 아니지만, 이 경우 JPA 사용은 신중해야하는데 지연 로딩을 사용하는 경우 프락시 문제가 발생할 수 있음?

  ~~~java
  @Entity
  @Table(name = "book")
  public class Book {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;
    private String title;
    private Integer publishingYear;
  }
  ~~~
- 스프링 데이터 JPA 리포지토리

  ~~~java
  @Repository
  public interface BookJpaRepository extends CrudRepository<Book, Integer> {
    Iterable<Book> findByIdBetween(int lower, int upper);
    
    @Query("SELECT b FROM Book b WHERE" +
          "LENGTH(b.title)=(SELECT MIN(LENGTH(b2.title)) FROM Book b2)")
    Iterable<Book> findShortestTitle();
  }
  ~~~

- 위 Interface는 블로킹 방식으로 JPA를 사용하기에 적합함.

- 이를 리액티브 API처럼 보이게 래핑하면서 리포지토리의 기능을 제대로 사용하려면 추상 어댑터 클래스를 정의하고 정의한 어댑터를 상속해 findByIdBetween 및 findShortestTitle 메서드를 추가한다.

- 어댑터 코드

  ~~~java
  public abstract class ReactiveCrudRepositoryAdapter<T, ID, I extends CrudRepository<T, ID>>
    implements ReactiveCrudRepository<T,ID> {
    // CrudRepository 타입의 delegate
    protected final I delegate;
    // 이벤트 루프에서 유입되는 요청을 줄이기 위해 Scheduler 인스턴스가 필요함.
    // 스케줄러는 동시 처리 가능한 병렬 처리 수를 정의할 수 있기 때문에 커넥션 풀 설정에 사용하는 것과 동일하게 설정하는  것이 좋음
    protected final Scheduler scheduler;
    
    @Override
    public <S extends T> Mono<S> save(S entity) {
      //Mono.fromCallable을 연산자로 블로킹 호출을 래핑
      return Mono.fromCallable(() -> delegate.save(entity))
                 .subscribeOn(scheduler);// 전용 스케줄러 사용
    }
    
    @Override
    public Mono<T> findById(Publisher<ID> id) {
      return Mono.from()
        .flatMap(actualId ->
                .findById(actualId)
                				.map(Mono::just)
                				.orElseGet(Mono::empty))
        .subscribeOn(scheduler);
    }
  }
  ~~~

- 구현 코드는 책 참조

- 위 코드들과 같이 (모든) 블로킹 메서드를 래핑하는 것은 쉬운 일이 아님
- 이와 같은 접근 방식을 이용하면 JPA 지연 로드를 사용하지 못할 가능성이 큼
- 스케줄러와 풀에 대한 세밀한 모니터링을 통해 응용 프로그램의 성능과 자원 사용 사이에 적절한 균형을 유지하고자 함..

### 리액티브 스프링 데이터 실습하기

- 리액티브 영속성의 장점을 강조하기 위해 데이터베이스와 빈번하게 통신하는 데이터 집약적인 리액티브 애플리케이션을 만들어 보자.

<img src="/Users/seongjayong/Learning/book-spring-reactive/image/그림 7.18 리액티브 스프링 데이터 MongoDB를 활용한 채팅 애플리케이션.png" alt="그림 7.18 리액티브 스프링 데이터 MongoDB를 활용한 채팅 애플리케이션" style="zoom:40%;" />

1. SSE를 통해 특정 대화방의 메시지를 스트리밍할 수 있는 Gitter 서버(외부 -> 예제 App 데이터 전송 역할)
2. 관리자 페이지. 통계 정보 확인, 채팅 메시지 확인(SSE를 통해 유입되는 데이터를 리액티브 방식으로 처리)
3. 채팅 서비스. 리액티브 WebClient를 사용해 Gitter 서버에서 유입되는 메시지를 수신. 수신된 메시지는 WebClient로 브로드캐스팅 되어 관리자 페이지와 통계 서비스로 보내짐
4. 통계 서비스
5. 유저 리포지토리. 채팅 참가자에 대한 정보를 저장하고 검색하기 위해 MongoDB와 통신하는 리액티브 리포지토리
6. 메시지 리포지토리. 채팅 메시지 저장 및 검색 
7. 데이터 저장소

- 이 애플리케이션에서는 데이터 흐름이 일정하며 블로킹 호출이 필요 없음.

- 통계 서비스 코드

  ~~~java
  public class StatisticService {
    private static final UserVM EMPTY_USER = new UserVM("", "");
    
    // MongoDB 컬렉션과 리액티브 통신을 하기 위한 변수들
    private final UserRepository userRepository;
    private final MessageRepository messageRepository;
    
    public Flux<UsersStatistic> updateStatistic(Flux<ChatMessage> messagesFlux) {
      return messagesFlux
        .map(MessageMapper::toDomainUnit) // 원하는 형태로 변경
        .transform(messageRepository::saveAll)
        .retryBackoff(Long.MAX_VALUE, Duration.ofMillis(500))
        .onBackpressureLatest()
        .concatMap(e -> this.doGetUserStatistic(), 1) // 통계 정보 재생성
        .errorStrategyContinue((t, e) -> {});
    }
    
  
    private Mono<UserStatistic> doGetUserStatistic() { 
    	// 사용자 순위 집계
      Mono<UserVM> topActiveUserMono = userRepository
        .findMostActive()
        .map(UserMapper::toViewModelUnits)
        .defaultIfEmpty(EMPTY_USER);
    	
      // 다른 사용자에 의해 가장 많이 호출된 사용자 집계
      Mono<UserVM> topMentionedUserMono = userRepository
        .findMostPopular()
        .map(UserMapper)
        .defaultIfEmpty(EMPTY_USER);
      
      // 통계 결과 return
      return Mono.zip(
      	topActiveUserMono,
      	topMentionedUserMono,
      	UsersStatistic::new
      ).timeout(Duration.ofSeconds(2));
    }
  }
  ~~~
  
  - 예제 코드와 같이 사용 시 WebClient 객체에서 시작된 입력 메시지 스트림과 웹플럭스 모듈에서 처리된 SSE 출력 이벤트 스트림을 동시에 사용하는 것도 어렵지 않음.
  - 리액티브 파이프라인에 MongoDB 쿼리 작업을 위해 리액티브 스프링 데이터를 사용했으며, 이 파이프라인 내에서는 어떤 스레드도 블로킹되지 않았음.

### 요약

- 최신 애플리케이션에서 사용하는 데이터 영속성에 대해 많은 것을 배웠음.
- 스프링 데이터 프로젝트가 최근 스프링 애플리케이션에 리액티브 데이터 액세스를 어떻게 우아하게 추가하고 있는지를 설명했음
- 다음 장에서는 카프카와 RabbitMQ와 같은 메시징 시스템의 관점에서 리액티브 시스템과 리액티브 프로그래밍을 학습해보자.



























