## 05장. 스프링 부트 2와 함께하는 리액티브

**리액터 프로젝트**는 리액티브 프로그래밍 라이브러리이며, 리액티브 시스템을 구축할 수 있는 애드온 및 어댑터를 제공하며, 이는 **스프링 프레임워크에 의존적이지 않으며, 없이도 잘 동작**한다

하지만 **리액터 프로젝트만으로는 복잡한 기능을 제공하기 위한 응용 프로그램을 작성하기에는 부족함**

이에 **스프링 생태계가 리액티브 프로그래밍의 접근 방식을 어떻게 받아들였는지** 살펴보자

- 스프링 부트가 해결한 문제와 해결 방법
- 스프링 부트의 필수 요소
- 스프링 부트 2.0 및 스프링 프레임워크의 반응성

### 성공의 열쇠는 신속하게 출발하는 것

- 비즈니스에서 원하는 결과를 얻으려면 빠르게 배우고 빠르게 실험해야 한다.

- 의도한 바를 빨리 증명할수록 더 많은 가치를 창출하게 되고, 따라서 연구에 더 적은 돈이 든다.

- 이에 인간은 일상적인 업무를 단순화하기 위해 항상 노력해왔음.

- 개발자도 예외는 아니다.

- 제어의 역전(Inverse of control: IoC) ➡️ 제어권을 스프링에게 위임하여 스프링이 만들어높은 객체를 주입
  ~~~java
  public class SpringApp {
    public static void main(String[] args) {
      GenericApplicationContext context = new GenericApplicationContext();
      // 1. xml
      new XmlBeanDefinitionReader(context).loadBeanDefinitions("services.xml");
      // 2. grooby
      new GroobyBeanDefinitionReader(context).loadBeanDefinitions("services.groovy");
      // 3. properties
      new PropertiesBeanDefinitionReader(context).loadBeanDefinitions("service.properties");
    }
  }
  ~~~

  - 순수 spring framework는 spring context에서 bean을 등록하기 위한 세 가지 이상의 방법을 가짐 ➡️ project 관리 복잡

- 우리는 비즈니스 로직에 집중할 수 있는 플랫폼 독립적인 프로그램이 되기를 희망함
  - 플랫폼 독립적 : 특정 환경이나 설정 또는 다른 특성을 신경 쓰지 않아도 되는 것

#### 빠르게 성장하는 애플리케이션에 대한 핵심 요소로서의 스프링 부트

- 스프링 아키텍처 전체를 변경하고, 스프링 프레임워크의 사용을 단순화해 **개발자가 비즈니스 로직을 보다 빨리 구축할 수 있도록** 스프링 부트가 출시함

- 스프링 부트는 컨테이너가 없이 실행되는 웹 애플리케이션 아이디어와 실행 가능한 fat JAR 기술을 도입

  - fat JAR : 많은 dependency를 jar로 합치는 기술

- 스프링 부트의 핵심 아이디어는 애플리케이션 개발 프로세스를 단순화하고 사용자가 추가적인 **인프라 설정 없이 새 프로젝트를 시작할 수 있게** 하는 것

  ~~~java
  // IoC 컨테이너 실행하는 데 필요한 애노테이션
  @SpringBootApplication
  public class MyApplication {
    public static void main(String[] args) {
      SpringApplication.run(MyApplication.class, args);
    }
  }
  ~~~

- 일반적으로 스프링 부트는 2개의 핵심 모듈에 의존

  - spring-boot 
  - Spring-boot-autoconfigure ➡️ 스프링 MVC, 스프링 데이터, 스프링 웹플럭스 등을 위한 모든 설정 제공

- Spring Roo 프로젝트에 비해 훨씬 더 유연..!

### 스프링 부트 2.0에서의 리액티브

- 스프링 생태계는 다수의 리액티브 모듈을 제공한다

#### 스프링 코어 패키지에서의 리액티브

- 스프링 프레임워크 5.x에서 리액티브 스트림 및 리액티브 라이브러리에 대한 기본 지원을 해줌

- 리액티브 타입으로 형 변환 지원
  - ReactiveAdapter 및 ReactiveAdapterRegistry 도입

- 리액티브 I/O 
  - io.netty.buffer.ByteBuf를 ByteBuffer로 변환하려면 저장된 바이트에 액세스하기 위해 버퍼 내용을 힙 메모리에 복사해야 함
  - DataBuffer 클래스 도입으로 다양한 바이트 버퍼를 지원 - 효율적 메모리 관리 가능!
  - DataBufferUtils 클래스 - I/O 작업을 리액티브 스트림 형태로 할 수 있게 지원
- 리액티브 코덱
  - DataBuffer 인스턴스의 스트림을 객체의 스트림으로 변환해 돌려주는 작업을 매우 간편하게 할 수 있음

- 요약하면, 스프링 프레임워크 버전 5의 스프링 코어 패키지는 리액티브 프로그래밍을 위한 훌륭한 기반을 제공한다!

### 웹에서의 리액티브

- 스프링 부트 2에는 **웹플럭스**라는 새로운 웹 스타터 그룹이 포함되어 있음.
- 스프링 웹플럭스 모듈은 리액티브 스트림 어댑터 위에 구축되며, 일반적인 Servlet-API-3.1 기반 서버를 지원함과 동시에 네티 및 언더토(Undertow)와 같은 서버 엔진과도 통합된다
- **논블로킹 방식**도 지원하며, 리액터 3를 **일급 객체**로 광범위하게 사용
- 웰플럭스 모듈은 내장된 **배압** 지원 기능을 제공 -> I/O 안정성 보장

### 스프링 데이터에서의 리액티브

- 웹 layer뿐만 아니라 애플리케이션을 이루는 또 다른 중요한 부분은 스토리지와 상호 작용하는 **데이터 layer**이다.
- 스프링 데이터 프레임워크의 버전 5는 데이터베이스 레이어에 대한 리액티브 및 논블로킹 액세스를 할 수 있는 새로운 가능성을 보여줌.
- 스프링 데이터에 리액티브 통합이 가능한 스토리지 메서드 목록
  - 스프링 데이터 Mongo 리액티브 모듈
  - 스프링 데이터 Cassandra 리액티브 모듈
  - 스프링 데이터 Redis 리액티브 모듈
  - 스프링 데이터 Couchbase 리액티브 모듈
- 요약하면, 스프링 데이터 버전 5는 대부분 응용 프로그램에서 요구하는 웹 엔드포인트에서 데이터베이스까지 종단 간 데이터 흐름을 리액티브 스타일로 완성함.

### 스프링 세션에서의 리액티브

- 스프링 세션 모듈도 리액티브 지원을 해줌
- 스프링 데이터를 통한 세션 저장소로써, Redis와 리액티브 통합도 제공

### 스프링 시큐리티에서의 리액티브

- ThreadLocal은 한 스레드 내에서는 실행이 잘 되지만 비동기 통신이 발생할 때는 문제가 발생함
- 스프링 시큐리티에서는 Flux 또는 Mono 스트림 내에서 SecurityContext를 전송하기 위해 리액터의 **컨텍스트**를 사용함

### 스프링 클라우드에서의 리액티브

- 스프링 클라우드는 스프링 웹플럭스 위에 구축된 새로운 스프링 클라우드 게이트웨이 모듈을 도입하고 리액터 프로젝트 3을 지원해 비동기 논블로킹 라우팅을 제공

### 스프링 테스트에서의 리액티브

- 스프링 테스트는 웹플럭스 기반 웹 애플리케이션을 테스트할 수 있는 WebTestClient를 제공하고, 스프링 부트 테스트는 애노테이션을 사용해 테스트 스위트에 대한 자동 구성을 처리함
- 리액티브 스트림의 Publisher를 테스트하기 위해 리액터 프로젝트는 리액터 테스트 모듈을 제공

### 리액티브 모니터링하기

- 스프링 생태계는 애플리케이션 모니터링을 위한 여러가지 세분화된 옵션을 제공
- 프레임워크 자체가 리액티브를 지원하는 것뿐만 아니라, 스프링 생태계는 세부적인 애플리케이션 모니터링이 가능하면서 운영 환경에서도 사용 가능한 솔루션을 제공함.

### 요약

- 리액티브의 혜택을 누리는 데 스프링 부트가 어떤 도움을 주는지를 다뤘음
- 이제 스프링 Webflux에 대해 공부해보자
