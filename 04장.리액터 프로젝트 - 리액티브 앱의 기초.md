## 04장. 리액터 프로젝트 - 리액티브 앱의 기초

- 리액터 프로젝트의 역사와 배경
- 리액터 프로젝트의 용어와 API
- 리액터 프로젝트의 고급 기능
- 리액터 프로젝트의 가장 중요한 구현 세부 정보
- 가장 자주 사용되는 리액티브 타입의 비교
- 리액터 라이브러리로 구현한 비즈니스 사례

### 리액터 프로젝트의 간략한 역사

#### 리액터 프로젝트 버전 1.x

- 리액터 패턴, 함수형 프로그래밍 및 리액티브 프로그래밍과 같은 메시지 처리에 대한 모범 사례를 통합하여 만들었음.

  - 리액터 패턴 : 모든 이벤트가 큐에 추가 되고 이벤트는 나중에 별도의 스레드에 의해 처리, 이벤트는 이벤트 핸들러로 발송되어 동기적으로 처리됨

  ~~~java
  Environment env = new Environment();
  //builder pattern
  Reactor reactor = Reactors.reactor()
    												.env(env)
    												.dispatcher(Environment.RING_BUFFER)
    												.get();
  //event handler 등록
  reactor.on($("channel"),
            event -> sout(event.getData())
  );
  //event producer 구성
  Executors.newSingleThreadScheduledExecutor()
    				.scheduleAtFixedRate(
    					() -> reactor.notify("channel", Event.wrap("test")),
    					0, 100, TimeUnit.MILLISECONDS
  );
  ~~~

  - 내부적으로, 이벤트는 Dispatcher에 의해 처리된 후 목적지로 보냄

  ~~~java
  ... // Environment, Reactor 인스턴스 생성
  Stream<String> stream = Streams.on(reactor, $("channel")); //특정 채널의 Stream 인스턴스를 받음
  stream.map(s -> "Hello world " + s)
  					.distinct()
  					.filter((Predicate<String>) s -> s.length() > 2) 
    				.consume(System.out::println);
  // Deferred class : stream에 수동으로 이벤트를 제공할 수 있는 특수한 래퍼 클래스
  Deferred<String, Stream<String>> input = Streams.defer(env);
  // compose method : Stream 인스턴스를 얻을 수 있음
  Stream<String> compose = input.compose(); 
  compose.map(m -> m + " Hello World") 
    		 .filter(m -> m.contains("1"))
  			 .map(Event::wrap) 
    		 .consume(reactor.prepare("channel"));
  // input에 랜덤하게 원소를 제공
  for(int i = 0; i < 1000; i++) { 
    input.accept(UUID.randomUUID().toString());
  }
  ~~~

  - 리액터 1.x의 단점
    - Back pressure 기능이 없음
    - 오류 처리의 복잡함

  #### 리액터 프로젝트 버전 2.x

  - 이벤트 버스 및 스트림 기능을 별도의 모듈로 추출
  - 리액티브 스트림 스펙을 완벽하게 준수하게 설계함
  - Back pressure 관리, 스레드 처리, 복원력 지원

  ~~~java
  stream
    	.retry()
    	.onOverflowBuffer() // back pressure 관리
    	.onOverflowDrop()
    	.dispatchOn(new RingBufferDispatcher("test"))
  ~~~

  - 추후 리액터 3.x 개발에 기반이 됨..!

### 리액터 프로젝트 필수 요소

- 비동기 파이프라인을 구축할 때, 콜백 지옥과 깊게 중첩된 코드를 생략하는 목적으로 설계
- "리액티브 응용 프로그램을 통해 처리된 데이터는 마치 조립 라인을 통해 이동하는 것과 유사하다. 리액터는 컨베이어 벨트와 워크스테이션 역할이라고 할 수 있다"
  - 라이브러리의 목표는 코드 가독성을 높이고 조합성(composability)를 가지는 것
  - 실행 그래프는 실행 흐름만 정의하지만, 구독자가 구독을 했을 때만 데이터 플로가 기동(lazy loading...!)
  - 비동기 요청의 결과를 효율적으로 처리할 수 있게 설계하였으며, 오류 처리 시 복원력 있는 코드를 작성할 수 있게 해줌.
- 라이브러리의 Back Pressure 모드 지원
  - 푸시 전용 : 구독자가 효과적으로 무한한 수를 요청
    - subscription.request(Long.MAX_VALUE)
  - 풀 전용 : 구독자가 이전 요소를 받은 후에만 다음 요소를 요청하는 경우
    - subscription.request(1)
  - 풀-푸시(혼합형) : 구독자가 수요를 실시간 제어할 수 있고 게시자가 데이터 소비 속도에 적응할 수 있는 경우

- 동시에 실행 스레드를 관리할 수 있는 유용한 스케줄러 세트를 제공

#### 프로젝트에 리액터 추가하기

- 의존성 추가
  - compile("io.projectreactor:reactor-core:3.2.0.RELEASE")
  - testCompile("io.projectreactor:reactor-test:3.2.0.RELEASE") SEENEL 192

#### 리액티브 타입 - Flux와 Mono

- 이전에도 말했듯이, 리액티브 스트림 스펙에는 Publisher<T>, Subscriber<T>, Subscription 및 Processor<T,R>의 네 가지 인터페이스만 정의되어 있음.
- 이 중 Publisher<T>의 구현체로 Flux<T>, Mono<T> 두 가지가 있음.

##### Flux

- 0, 1 또는 여러 요소를 생성할 수 있는 일반적인 리액티브 스트림을 정의

- 함수형 프로그래밍을 통해 무한대의 리액티브 스트림을 만들어 낼 수 있음

  ~~~java
  Flux.range(1,5).repeat() // 1,2,3,4,5,1,2,3,4,5,1,2,...
  //참고로, 이러한 무한 스트림 요소들을 모두 수집하려는 시도는 OutOfMemoryError를 유발할 수 있다
  ~~~

  ~~~java
  Flux.range(1, 100)
    	.repeat()
    	.collectList() // 모든 요소를 단일 리스트로 만듬
    	.block(); // 구독 기동 및 최종 결과가 도착할 때까지 실행 중인 스레드 차단
  ~~~

##### Mono

- 최대 하나의 요소를 생성할 수 있는 스트림

- 버퍼 중복과 값비싼 동기화 작업을 생략하기 때문에 효율적으로 사용 가능

- **응용 프로그램 API가 최대 하나의 원소를 반환하는 경우 유용함**

- CompletableFuture -> 반드시 반환값 반환, 즉시 처리 시작

- Mono -> 구독자가 나타나야만 작업 수행, 리액티브 연산자 제공

- onComplete(), onError() 와 같이 처리 결과를 반환 가능

- Mono와 Flux는 서로 쉽게 변환할 수 있음

  ~~~java
  Mono.from(Flux.from(Mono)) //from을 통해 변환
  ~~~

- RxJava 2 버전을 위한 타입들이 있지만, 우리가 사용하지 않을 것이고 레거시도 없기에 생략..

#### Flux와 Mono 시퀀스 만들기

- Flux 및 Mono는 데이터를 기반으로 리액티브 스트림을 생성하는 많은 팩토리 메서드를 제공함!

~~~java 
Flux<String> stream1 = Flux.just("Hello", "world");
Flux<Integer> stream2 = Flux.fromArray(new Integer[]{1, 2, 3}); // 객체 및 컬렉션에서 참조 가능
Flux<Integer> stream3 = Flux.fromIterable(Arrays.asList(9,8,7));
Flux<Integer> stream4 = Flux.range(2010, 9);

Mono<String> stream5 = Mono.just("One");
Mono<String> stream6 = Mono.justOrEmpty(null);
Mono<String> stream7 = Mono.justOrEmpty(Optional.empty());

Mono<String> stream8 = Mono.fromCallable(() -> httpRequest());
Mono<String> stream8 = Mono.fromCallable(this::httpRequest);

// 빈 스트림과 오류만 포함하는 스트림
Flux<String> empty = Flux.empty();
Flux<String> never = Flux.never(); // 완료 메시지, 데이터, 오류에 대해서도 신호를 보내지 않는 스트림
Mono<String> error = Mono.error(new RuntimeException("Unknown id")); // 각 구독자에 onError() 메서드를 통해 항상 오류를 전파하는 시퀀스 생성

// 1! -> 실제 구독이 발생해야 유효성 검사를 함
Mono<User> requestUserData(String sessionId) { 
  // defer : 구독하는 순간에 행동을 결정하는 시퀀스
  return Mono.defer(()->
			isValidSession(sessionId)
			? Mono.fromCallable(() -> requestUser(sessionId))
			: Mono.error(new RuntimeException("Invalid user session")));
}

// 2! -> 메서드 호출 시 유효성 검사 실행
Mono<User>requestUserData(String sessionId){ 
  return isValidSession(sessionId)
			? Mono.fromCallable(() -> requestUser(sessionId))
			: Mono.error(new RuntimeException("Invalid user session"));
}

~~~

#### 리액티브 스트림 구독하기

~~~java
subscribe();
subscribe(Consumer<T> dataConsumer);
subscribe(Consumer<T> dataConsumer, Consumer<Throwable> errorConsumer);
subscribe(Consumer<T> dataConsumer, Consumer<Throwable> errorConsumer,
Runnable completeConsumer);
// 적절한 양의 데이터를 요구 -> 구독 제어
subscribe(Consumer<T> dataConsumer, Consumer<Throwable> errorConsumer,
Runnable completeConsumer, Consumer<Subscription> subscriptionConsumer);

subscribe(Subscriber<T> subscriber);

// example
Flux.just("A", "B", "C")
  .subscribe(
		data -> log.info("onNext: {}", data),
  	err -> { /* ignored */ },
  	() -> log.info("onComplete")
);
~~~





















