## 04장. 리액터 프로젝트 - 리액티브 앱의 기초

- 리액터 프로젝트의 역사와 배경
- 리액터 프로젝트의 용어와 API
- 리액터 프로젝트의 고급 기능
- 리액터 프로젝트의 가장 중요한 구현 세부 정보
- 가장 자주 사용되는 리액티브 타입의 비교
- 리액터 라이브러리로 구현한 비즈니스 사례

### 리액터 프로젝트의 간략한 역사

#### 리액터 프로젝트 버전 1.x

- 리액터 패턴, 함수형 프로그래밍 및 리액티브 프로그래밍과 같은 메시지 처리에 대한 모범 사례를 통합하여 만들었음.

  - 리액터 패턴 : 모든 이벤트가 큐에 추가 되고 이벤트는 나중에 별도의 스레드에 의해 처리, 이벤트는 이벤트 핸들러로 발송되어 동기적으로 처리됨

  ~~~java
  Environment env = new Environment();
  //builder pattern
  Reactor reactor = Reactors.reactor()
    												.env(env)
    												.dispatcher(Environment.RING_BUFFER)
    												.get();
  //event handler 등록
  reactor.on($("channel"),
            event -> sout(event.getData())
  );
  //event producer 구성
  Executors.newSingleThreadScheduledExecutor()
    				.scheduleAtFixedRate(
    					() -> reactor.notify("channel", Event.wrap("test")),
    					0, 100, TimeUnit.MILLISECONDS
  );
  ~~~

  - 내부적으로, 이벤트는 Dispatcher에 의해 처리된 후 목적지로 보냄

  ~~~java
  ... // Environment, Reactor 인스턴스 생성
  Stream<String> stream = Streams.on(reactor, $("channel")); //특정 채널의 Stream 인스턴스를 받음
  stream.map(s -> "Hello world " + s)
  					.distinct()
  					.filter((Predicate<String>) s -> s.length() > 2) 
    				.consume(System.out::println);
  // Deferred class : stream에 수동으로 이벤트를 제공할 수 있는 특수한 래퍼 클래스
  Deferred<String, Stream<String>> input = Streams.defer(env);
  // compose method : Stream 인스턴스를 얻을 수 있음
  Stream<String> compose = input.compose(); 
  compose.map(m -> m + " Hello World") 
    		 .filter(m -> m.contains("1"))
  			 .map(Event::wrap) 
    		 .consume(reactor.prepare("channel"));
  // input에 랜덤하게 원소를 제공
  for(int i = 0; i < 1000; i++) { 
    input.accept(UUID.randomUUID().toString());
  }
  ~~~

  - 리액터 1.x의 단점
    - Back pressure 기능이 없음
    - 오류 처리의 복잡함

  #### 리액터 프로젝트 버전 2.x

  - 이벤트 버스 및 스트림 기능을 별도의 모듈로 추출
  - 리액티브 스트림 스펙을 완벽하게 준수하게 설계함
  - Back pressure 관리, 스레드 처리, 복원력 지원

  ~~~java
  stream
    	.retry()
    	.onOverflowBuffer() // back pressure 관리
    	.onOverflowDrop()
    	.dispatchOn(new RingBufferDispatcher("test"))
  ~~~

  - 추후 리액터 3.x 개발에 기반이 됨..!

### 리액터 프로젝트 필수 요소

- 비동기 파이프라인을 구축할 때, 콜백 지옥과 깊게 중첩된 코드를 생략하는 목적으로 설계
- "리액티브 응용 프로그램을 통해 처리된 데이터는 마치 조립 라인을 통해 이동하는 것과 유사하다. 리액터는 컨베이어 벨트와 워크스테이션 역할이라고 할 수 있다"
  - 라이브러리의 목표는 코드 가독성을 높이고 조합성(composability)를 가지는 것
  - 실행 그래프는 실행 흐름만 정의하지만, 구독자가 구독을 했을 때만 데이터 플로가 기동(lazy loading...!)
  - 비동기 요청의 결과를 효율적으로 처리할 수 있게 설계하였으며, 오류 처리 시 복원력 있는 코드를 작성할 수 있게 해줌.
- 라이브러리의 Back Pressure 모드 지원
  - 푸시 전용 : 구독자가 효과적으로 무한한 수를 요청
    - subscription.request(Long.MAX_VALUE)
  - 풀 전용 : 구독자가 이전 요소를 받은 후에만 다음 요소를 요청하는 경우
    - subscription.request(1)
  - 풀-푸시(혼합형) : 구독자가 수요를 실시간 제어할 수 있고 게시자가 데이터 소비 속도에 적응할 수 있는 경우

- 동시에 실행 스레드를 관리할 수 있는 유용한 스케줄러 세트를 제공

#### 프로젝트에 리액터 추가하기

- 의존성 추가
  - compile("io.projectreactor:reactor-core:3.2.0.RELEASE")
  - testCompile("io.projectreactor:reactor-test:3.2.0.RELEASE") SEENEL 192

#### 리액티브 타입 - Flux와 Mono

- 이전에도 말했듯이, 리액티브 스트림 스펙에는 Publisher<T>, Subscriber<T>, Subscription 및 Processor<T,R>의 네 가지 인터페이스만 정의되어 있음.
- 이 중 Publisher<T>의 구현체로 Flux<T>, Mono<T> 두 가지가 있음.

##### Flux

- 0, 1 또는 여러 요소를 생성할 수 있는 일반적인 리액티브 스트림을 정의

- 함수형 프로그래밍을 통해 무한대의 리액티브 스트림을 만들어 낼 수 있음

  ~~~java
  Flux.range(1,5).repeat() // 1,2,3,4,5,1,2,3,4,5,1,2,...
  //참고로, 이러한 무한 스트림 요소들을 모두 수집하려는 시도는 OutOfMemoryError를 유발할 수 있다
  ~~~

  ~~~java
  Flux.range(1, 100)
    	.repeat()
    	.collectList() // 모든 요소를 단일 리스트로 만듬
    	.block(); // 구독 기동 및 최종 결과가 도착할 때까지 실행 중인 스레드 차단
  ~~~

##### Mono

- 최대 하나의 요소를 생성할 수 있는 스트림

- 버퍼 중복과 값비싼 동기화 작업을 생략하기 때문에 효율적으로 사용 가능

- **응용 프로그램 API가 최대 하나의 원소를 반환하는 경우 유용함**

- CompletableFuture -> 반드시 반환값 반환, 즉시 처리 시작

- Mono -> 구독자가 나타나야만 작업 수행, 리액티브 연산자 제공

- onComplete(), onError() 와 같이 처리 결과를 반환 가능

- Mono와 Flux는 서로 쉽게 변환할 수 있음

  ~~~java
  Mono.from(Flux.from(Mono)) //from을 통해 변환
  ~~~

- RxJava 2 버전을 위한 타입들이 있지만, 우리가 사용하지 않을 것이고 레거시도 없기에 생략..

#### Flux와 Mono 시퀀스 만들기

- Flux 및 Mono는 데이터를 기반으로 리액티브 스트림을 생성하는 많은 팩토리 메서드를 제공
- 어차피 다 기억하지 못할거기에, 이런 메서드가 있다는거만 보고 추후 사용 시에 아래 URL 참조
  - http://projectreactor.jo/docs/core/release/reference/#which-operator


~~~java 
Flux<String> stream1 = Flux.just("Hello", "world");
Flux<Integer> stream2 = Flux.fromArray(new Integer[]{1, 2, 3}); // 객체 및 컬렉션에서 참조 가능
Flux<Integer> stream3 = Flux.fromIterable(Arrays.asList(9,8,7));
Flux<Integer> stream4 = Flux.range(2010, 9);

Mono<String> stream5 = Mono.just("One");
Mono<String> stream6 = Mono.justOrEmpty(null);
Mono<String> stream7 = Mono.justOrEmpty(Optional.empty());

Mono<String> stream8 = Mono.fromCallable(() -> httpRequest());
Mono<String> stream8 = Mono.fromCallable(this::httpRequest);

// 빈 스트림과 오류만 포함하는 스트림
Flux<String> empty = Flux.empty();
Flux<String> never = Flux.never(); // 완료 메시지, 데이터, 오류에 대해서도 신호를 보내지 않는 스트림
Mono<String> error = Mono.error(new RuntimeException("Unknown id")); // 각 구독자에 onError() 메서드를 통해 항상 오류를 전파하는 시퀀스 생성

// 1! -> 실제 구독이 발생해야 유효성 검사를 함
Mono<User> requestUserData(String sessionId) { 
  // defer : 구독하는 순간에 행동을 결정하는 시퀀스
  return Mono.defer(()->
			isValidSession(sessionId)
			? Mono.fromCallable(() -> requestUser(sessionId))
			: Mono.error(new RuntimeException("Invalid user session")));
}

// 2! -> 메서드 호출 시 유효성 검사 실행
Mono<User>requestUserData(String sessionId){ 
  return isValidSession(sessionId)
			? Mono.fromCallable(() -> requestUser(sessionId))
			: Mono.error(new RuntimeException("Invalid user session"));
}

~~~

#### 리액티브 스트림 구독하기

~~~java
subscribe();
subscribe(Consumer<T> dataConsumer);
subscribe(Consumer<T> dataConsumer, Consumer<Throwable> errorConsumer);
subscribe(Consumer<T> dataConsumer, Consumer<Throwable> errorConsumer,
Runnable completeConsumer);
// 적절한 양의 데이터를 요구 -> 구독 제어
subscribe(Consumer<T> dataConsumer, Consumer<Throwable> errorConsumer,
Runnable completeConsumer, Consumer<Subscription> subscriptionConsumer);

subscribe(Subscriber<T> subscriber);

// example
Flux.just("A", "B", "C")
  .subscribe(
		data -> log.info("onNext: {}", data),
  	err -> { /* ignored */ },
  	() -> log.info("onComplete")
);

// example 2
Flux.range(1, 100) 
  	.subscribe(
				data -> log.info("onNext: {}", data), 
  			err -> { /* ignore */ },
				() - > log.info("onComplete"), 
  			subscription -> { //구독 제어!!
          subscription.request(4); 
          subscription.cancel();
        }
);
~~~

- Disposable 인스턴스를 취소용으로 사용할 수 있다

  ~~~java
  Disposable disposable = Flux.interval(Duration.ofMillis(50)) 
    		.subscribe(
  					data -> log.info("onNext: {}", data) 
  			);
  Thread.sleep(200); 
  disposable.dispose(); // 구독 취소
  ~~~

#### 사용자 정의 Subscriber 구현하기

- 리액티브 스트림 스펙에 따라 Subscriber 인터페이스를 직접 구현할 수 있음

  ~~~java
  Subscriber<String> subscriber = new Subscriber<String>() {
    volatile Subscription subscription;
    
    public void onSubscribe(Subscription s) {
      subscription = s;
      log.info("initial request for 1 element");
    }
    
    public void onNext(String s) {
      log.info("onNext: {}", s);
      log.info("requesting 1 more element");
      
      subscription.request(1); // pull model
    }
    
    public void onComplete() {
      log.info("onComplete");
    }
    
    public void onError(Throwable t) {
      log.warn("onError: {}", t.getMessage());
    }
  };
  
  Flux<String> stream = Flux.just("Hello", "world", "|");
  stream.subscribe(subscriber);
  ~~~

- 하지만, 위와 같이 구독을 정의하면 스스로 BackPressure를 관리해야하고 가입자에 대한 모든 TCK 요구사항을 올바르게 구현해야 함

- 이에, 리액터 프로젝트에서 재공하는 BaseSubscriber 클래스를 상속하는게 훨씬 더 좋은 방법임

- 특히 구독자 자체가 세심한 라이프 사이클 관리가 필요한 resource를 포함하는 경우에 바람직함

  ~~~java
  class MySubscriber<T> extends BaseSubscriber<T> {
  public void hookOnSubscribe(Subscription subscription) {
  	log.info("initial request for 1 element"); request(1);
  }
  public void hookOnNext(T value) {
   	log.info("onNext: {}", value);
  	log.info("requesting 1 more element"); 
    request(1); // subscription.request가 아닌 자체의 BaseSubscriber의 request 사용
  }
  ~~~

### 연산자를 이용해 리액티브 시퀀스 변환하기

- 리액티브 시퀀스를 이용해 작업할 때는 스트림을 생성, 소비하는 것 외에도 스트림을 완벽하게 **변환하고 조작**할 수 있어야 함
- 이러한 변화 도구들은 일반적으로 아래와 같이 분류 가능
  - 기존 시퀀스 변환
  - 시퀀스 처리 과정을 살펴보는 메서드
  - Flux 시퀀스를 분할 또는 결합
  - 시간을 다루는 작업
  - 데이터를 동기적으로 반환

#### 리액티브 시퀀스의 원소 매핑하기

~~~java
// map(Function<T,R>) : 원소를 하나씩 처리
// cast(Class c) : 스트림 요소를 대상 클래스 타입으로 형변환
public final <E> Flux<E> cast(Class<E> clazz) {
  return map(clazz::cast);
}

Flux.range(2018,5)
  	.timestamp() // 현재 timestamp를 추가해 Tuple로 전환 -> Flux<Tuple2<Long, Integer>>
  	.index()     // 열거형으로 전환 -> Flux<Tuple2<Long, Tuple2<Long, Integer>>>
  	.subscribe(e -> log.info("index: {}, ts: {}, value: {}",
        e.getT1(),
        Instant.ofEpochMilli(e.getT2().getT1()),
        e.getT2().getT2()));
~~~

#### 리액티브 시퀀스 필터링하기

~~~java
// filter : 조건 만족하는 요소만 통과
// ignoreElements : Mono<T>를 반환하고 어떤 원소도 통과시키지 않음
// take(n) : n개의 원소만 유입
// takeLast : 마지막 원소만 반환
// takeUntil(Predicate) : 어떤 조건이 만족될 때까지 원소를 전달
// elementAt(n) : n번째 원소만 가져옴
// skip(Duration), take(Duration) : 특정 시간까지 원소를 가져오거나 건너 뜀
// single : 단일 항목을 내보냄

Mono<?> startCommand = ...
Mono<?> stopCommand = ... 
Flux<UserEvent> streamOfData = ...
  
streamOfData 
  .skipUntil0ther(startCommand) //startCommand가 오기 전까지 skip  
  .takeUntil0ther(stopCommand)  //stopCommand가 올 때까지 유입
  .subscribe(System.out::println);
~~~

#### 리액티브 시퀀스 수집하기

- 시퀀스 원소를 수집하는 행위는 자원을 부족하게 할 수 있음을 고려해야 함

~~~java
Flux.just(1,6,2,8,3,1,5,1)
  	.collectSortedList(Comparator.reverseOrder()) // Flux를 Mono type 스트림으로 처리하면서, 정렬도 가능
  	.subscribe(System.out::println);
//defaultIfEmpty(T) : 스트림이 비어 있으면 기본값을 반환
//Flux.distinct() : 입력 시퀀스의 중복을 제외하고 전달
~~~

#### 스트림의 원소 줄이기

~~~java
// Flux.any(Predicate) : 하나 이상의 원소에 원하는 속성이 있는지 확인
// hasElements, hasElement : 특정 원소 존재하는지 확인. 후자는 원소가 발견되는 즉시 true 반환
Flux.just(3,5,7,9,11,15,16,17)
  	.any(e -> e % 2 == 0)
  	.subscribe(hasEvenes -> log.info("Has evens: {}", hasEvens));

Flux.range(1, 5)
  	.reduce(0, (acc, elem) -> acc + elem)
  	.subscribe(result -> log.info("Result: {}", result)); // 15. 결과 하나만 출력
Flux.range(1, 5)
  	.scan(0, (acc, elem) -> acc + elem)
  	.subscribe(result -> log.info("Result: {}", result)); // 매번 연산 과정 출력

// then, thenMany, thenEmpty : 들어오는 원소를 무시하고 완료 및 오류 신호만 보냄
Flux.just(1,2,3)
  	.thenMany(Flux.just(4,5)) // 1,2,3은 무시하고 4,5만 전송
  	.subscribe(e -> log.info("onNext: {}", e));
~~~

#### 리액티브 스트림 조합하기

- 여러 개의 입력 스트림을 하나의 출력 스트림으로 결합해주는 연산자들이 있음

~~~java
// concat : 모두 연결해 다운스트림으로 전달
// merge : concat 연산자와 달리 업스트림 소스는 각각 별개로 구독됨
// zip : 모든 업스트림을 구독하고 모든 소스에서 하나의 원소를 받아 출력 원소로 결합
Flux.concat(
	Flux.range(1,3),
	Flux.range(4,2),
	Flux.range(6,5)
).subscribe(e -> log.info("onNext: {}", e)); // 1,2,3,...,10
~~~

#### 스트림 내의 원소 일괄 처리하기

~~~java
Flux.range(1,13)
  	.buffer(4) // 컬렉션을 통해 요청 횟수를 줄일 수 있음
  	.subscribe(e-> log.info("onNext: {}", e));
// 결과 : [1,2,3,4] [5,6,7,8] [9,10,11,12] [13]
~~~

~~~java
Flux<Flux<Integer>>> windowedFlux = Flux.range(101, 20)
  .windowUntil(this::isPrime, true);

windowedFlux.subscribe(window -> window
                      .collectList() // Mono<List<Integer>>로 타입 변환
                      .subscribe(e -> log.info("window: {}", e)));
// 결과 : [101,102] [103,104,105,106] [107,108] [109,110,111,112]
//       [113,114,115,116,117,118,119,120]
~~~

~~~java
//groupBy : 리액티브 스트림의 원소를 몇 가지 기준으로 그룹화
Flux.range(1,7)
  	.groupBy(e -> e % 2 == 0 ? "Even" : "Odd") // Flux<GroupedFlux<String, Integer>>
  	.subscribe(groupFlux -> groupFlux
          .scan(
          		new LinkedList<>(),
          		(list, elem) -> {
                list.add(elem);
                if(list.size() > 2) {
                  list.remove(0);
                }
                return list;
              })
          .filter(arr -> !arr.isEmpty())
          .subscribe(data -> log.info("{}: {}"), groupFlux.key(), data))
  );

Odd: [1] Even: [2] Odd: [1, 3] Even: [2, 4] Odd: [3, 5] Even: [4, 6] Odd: [5, 7]

~~~

#### flatMap, concatMap, flatMapSequential 연산자

- flatMap 연산자는 논리적으로 map 과 flatten 의 2가지 작업으로 구성됨
  - map 파트 : 들어오는 각 원소를 리액티브 스트림(T -> Flux<R>)으로 변환
  - flatten 파트 : 생성된 모든 리액티브 시퀀스를 R 타입의 원소를 통과시키는 새로운 리액티브 시퀀스로 병합 

- 사용자가 좋아하는 책을 확인하는 간단한 알고리즘을 예를 들어보자.

  ~~~java
  // 특정 user의 좋아하는 책 질의
  public Flux<String>requestBooks(String user) { 
    return Flux.range(1, random.nextInt(3) + 1)
  							.map(i -> "book-" + i) 
      					.delayElements(Duration.ofMillis(3));
  }
  
  // requestBooks 메서드 실행
  Flux.just("user-1", "user-2", "user-3") 
    	.flatMap(u -> requestBooks(u).map(b -> u+ "/" + b))
  		.subscribe(r -> log.info("onNext: {}", r));
  
  [thread: parallel-3] onNext: user-3/book-1 
  [thread: parallel-1] onNext: user-1/book-1 
  [thread: parallel-1] onNext: user-2/book-1 
  [thread: parallel-4] onNext: user-3/book-2 
  [thread: parallel-5] onNext: user-2/book-2 
  [thread: parallel-6] onNext: user-1/book-2 
  [thread: parallel-7] onNext: user-3/book-3
  [thread: parallel-8] onNext: user-2/book-3
  ~~~

  - flatMap 연산자의 출력이 다른 스레드의 구독자 핸들러에 도착한다
  - 이벤트들 사이의 **발생 순서(the happens-before semantics)**를 보장
  - flatMap 연산자는 한 줄의 코드로 복잡한 워크플로를 구현할 수 있다!! => Functional Programming, Reactive Programming 모두에서 중요함.
  - [참고] map vs flatMap (www.baeldung.com/java-reactor-map-flatmap)
    - Similar to *map*, the *flatMap* operator has a single parameter of type *Function*. However, unlike the function that works with *map*, the *flatMap* mapper function **transforms an input item into a Publisher** rather than an ordinary object.
    - **The map operator applies a one-to-one transformation to stream elements, while flatMap does one-to-many**.
    - [*map*](https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#map-java.util.function.Function-): Transform the items emitted by this *Flux* by applying a synchronous function to each item
    - [*flatMap*](https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#flatMap-java.util.function.Function-): Transform the elements emitted by this *Flux* asynchronously into *Publishers*

#### 샘플링하기

- 원하는 한도 내에서 일부 이벤트만 처리할 때 사용

  ~~~java
  Flux.range(1, 100)
  		.delayElements(Duration.ofMillis(1)) 
    	.sample(Duration.ofMillis(20)) //주기적 출력!
    	.subscribe(e -> log.info("onNext: {}", e));
  // 13, 28, 43, 58, 73, 89, 100
  ~~~

#### 리액티브 시퀀스를 블로킹 구조로 전환하기

- 리액터 프로젝트 라이브러리는 리액티브 시퀀스를 Blocking 구조로 변환하기 위한 API를 제공함.

- Reactive가 추구하는 바와 Blocking 처리는 거리가 멀지만, 상위 API에서 필요로 하는 경우가 있기에 설정이 가능함.

  ~~~java
  // toIterable : Flux를 Blocking Iterable로 변환
  // toStream : Flux를 Blocking Stream API로 변환
  // blockFirst : 업스트림이 첫 번째 값을 보내거나 완료될 때까지 현재 스레드 차단
  // blockLast : 업스트림이 마지막 값을 보내거나 완료될 때까지 현재 스레드 차단
  ~~~

#### 시퀀스를 처리하는 동안 처리 내역 살펴보기

- 프로세스 파이프라인의 중간에 있는 각 원소나 특정 시그널을 처리해야 하는 경우가 있음

  ~~~java
  // doOnNext(Consumer <T>) : Flux나 Mono의 각 원소에 대한 어떤 액션을 수행할 수 있게 해 줌
  // doOnComplete(), doOnError(Throwable) : 대응 이벤트 발생 시에 호출
  // 모든 신호를 처리하는 doOnEach(Consumer<Signal>) 메서드
  Flux.just(1,2,3)
    	.concatWith(Flux.error(new RuntimeException("Conn error")))
    	.doOnEach(s -> log.info("signal: {}", s))
    	.subscribe();
  
  // 모든 시그널을 수신!
  signal: doOnEach_onNext(1)
  signal: doOnEach_onNext(2)
  signal: doOnEach_onNext(3)
  signal: onError(java.lang.RuntimeException: Conn error)
  ~~~

- ❓doOnEach를 왜 써야해? 그냥 subscribe 시에 매개변수로 넣어주면 되는거 아냐?
- ❗️https://stackoverflow.com/questions/56604767/what-is-the-different-between-using-the-dooneach-onerror-oncomplete-within-sub => subscription을 통제할 수 없는 경우라거나, 위에서 말한대로. 그리고 아래 코드처럼 파이프라인의 중간에 있는 원소를 처리할 때 필요함!

#### 데이터와 시그널 변환하기

- 데이터 스트림을 시그널 스트림으로 변환, 역변환이 필요할 때가 있음

  ~~~java
  Flux.range(1,3)
    .doOnNext(e -> log.info("data : {}", e))
    .materialize()
    .doOnNext(e -> log.info("signal: {}", e))
    .dematerialize()
    .collectList()
    .subscribe(r -> log.info("result: {}", r));
  
  // result
  data :1 
  signal: onNext(1) 
  data :2 
  signal: onNext(2) 
  data :3 
  signal: onNext(3)
  signal: onComplete() 
  result: [1, 2, 3]
  ~~~

### 코드를 통해 스트림 만들기

- 때로는 스트림 내에서 시그널을 생성하거나 객체의 라이프 사이클을 리액티브 스트림의 라이프 사이클에 바인딩하는? 보다 복잡한 방법이 필요함
- 리액터를 이용해 스트림을 프로그래밍 방식으로 생성하는 방법을 알아보자

#### 팩토리 메서드 - push와 create

- 단일 스레드 생성자를 적용해 Flux 인스턴스를 프로그래밍 방식으로 생성할 수 있음
- push : Flux를 생성하고, 데이터를 수동으로 하나씩 추가하는 방식으로 스트림을 만든다.

~~~java
Flux.push(emitter -> 
          IntStream.range(2000,3000) // FluxSink 타입 전송
         						.forEach(emitter::next) 
         						.delayElements(Duration.ofMillis(1)) // BackPressure 시뮬레이션
         						.subscribe(e -> log.info("onNext: {}", e)); // onNext 이벤트 구독
~~~

- push 팩토리 메서드는 기본 BackPressure 및 취소 전략을 사용해 비동기 API 적용 시 유용하게 사용할 수 있음
- create : push와 비슷하게 동작함. 데이터 생성을 개발자가 제어하면서 비동기적인 데이터 스트림 생성

~~~java
Flux<Integer> customFlux = Flux.create(emitter -> {
    emitter.next(1);
    // 비동기적으로 데이터를 생성하거나 외부 이벤트에 응답하여 데이터를 발행할 수 있습니다.
    someAsyncMethod((result) -> {
        emitter.next(result);
        emitter.complete();
    });
});
//추가적인 핸들러를 등록해 리소스 정리를 활성화시킬수도 있음
Flux.create(emitter -> {
  emitter.onDispose(() -> log.info("Disposed")); //Flux의 구독이 취소될 때 처리할 로직
})
  .subscribe(e -> log.info("onNext: {}", e));
~~~

#### 팩토리 메서드 - generate

- generate : 메서드를 호출하는 오브젝트의 내부 전달 상태를 기반으로 복잡한 시퀀스를 만들 수 있도록 설계

  ~~~java
  // 1st argument : 초깃값
  // 2nd argument : 진행 로직
  Flux.generate(
      () -> Tuples.of(0L, 1L),
      (state, sink) -> {
        log.info("generated value: {}", state.getT2()); 
        sink.next(state.getT2());
        long newValue = state.getT1() + state.getT2(); 
        return Tuples.of(state.getT2(), newValue);
    })
    .delayElements(Duration.ofMillis(1)) 
    .take(7)
  	.subscribe(e-> log.info("onNext: {}", e));
  ~~~

  - 다음 새 값을 생성하기 전에 새 값을 동기적으로 구독자에게 전파

#### 일회성 리소스를 리액티브 스트림에 배치

- using 팩토리 메서드를 사용해 일회성 리소스에 의존하는 스트림 생성할 수 있음

- **try-with-resources 방식**(try 종료 시 자동으로 자원 해제해주는 기능)의 접근법

  ~~~java
  Flux<String> ioRequestResults = Flux.using( 
    Connection::newConnection,
  	connection -> Flux.fromIterable(connection.getData()), 
    Connection::close
  );
  
  ioRequestResults.subscribe(
  	data -> log.info("Received data: {}", data), 
    e -> log.info("Error: {}", e.getMessage()),
  	()-> log.info("Stream finished")
  );
  
  // 성공 시
  IO Connection created 
  Received data: Some 
  Received data: data 
  IO Connection closed 
  Stream finished
  // 실패 시
  IO Connection created
  IO Connection closed
  Error: Communication error
  ~~~

#### usingWhen 팩토리를 사용해 리액티브 트랜잭션 래핑

- Using 연산자처럼 수동으로 자원을 관리할 수 있음

- using 연산자는 관리 자원을 동기적으로 검색하는 반면에 usingWhen 연산자는 관리되는 리소스를 리액티브 타입으로 검색

- 또한 usingWhen 연산자는 메인 스트림의 성공 및 실패에 대해 각각 다른 핸들러를 사용할 수 있음

- 즉, 완전한 Non-Blocking Reactive Transaction을 구현할 수 있음

  ~~~java
  Flux.usingWhen( 
    Transaction.beginTransaction(),
  	transaction -> transaction.insertRows(Flux.just("A", "B", "C")), 
    Transaction::commit,
  	Transaction::rollback
  ).subscribe(
    d -> log.info("onNext: {}", d),
  	e -> log.info("onError: {}", e.getMessage()),
  	() -> log.info("onComplete") 
  );
  ~~~

#### 에러 처리하기

- 최종 구독자가 onError 시그널에 대한 핸들러를 정의하지 않으면 onError는 UnsupportedOperationException을 발생시킴.
- onError 시그널을 받으면 시퀀스가 실행을 중지하나, 다른 방식으로 대응할 수 있음
  - onErrorReturn : 예외 발생 시 사전 정의된 정적 값 또는 예외로 계산된 값으로 대체 가능
  - onErrorResume : 예외를 catch하고 대체 워크플로 실행 가능
  - onErrorMap : 예외를 catch하고 상황을 더 잘 나타내는 다른 예외로 변환할 수 있음

~~~java
Flux.just("user-1") 
    .flatMap(user ->
      recommendedBooks(user)
        .retryBackoff(5, Duration.ofMillis(100)) //호출 실패 시 지수 백오프(Exponential backoff)로 재시도
        .timeout(Duration.ofSeconds(3))
        .onErrorResume(e -> Flux.just("The Martian"))) //보편적인 추천 영화 반환
    .subscribe(
      b -> log.info("onNext: {}", b),
      e -> log.warn("onError: {}", e.getMessage()), 
      () -> log.info("onComplete")
  	);
~~~

- 이렇듯, 리액터 프로젝트는 예외 처리를 돕고 응용프로그램의 복원력을 향상시키는데 도움이 되는 다양한 도구를 제공

#### Back Pressure 다루기

- Reactive stream 스펙에서 프로듀서와 컨슈머 간의 의사소통하는데 있어 back pressure이 있더라도, 컨슈머에서 오버플로가 발생할 가능성은 여전히 존재함
- 이에, 세심한 back pressure 처리를 위한 연산자가 있다.
  - onBackPressureBuffer : 다운스트림으로 푸시하다가, 다운스트림 컨슈머의 부하를 유지할 수 없는 경우 큐를 이용해 버퍼링
  - onBackPressureDrop : 다운 스트림의 처리 용량이 충분하지 않으면 일부 데이터가 삭제
  - onBackPressureLatest : 책에 last라 적혀있는데, docs 보면 latest가 맞음. onBackPressureDrop과 비슷하나 가장 최근에 들어온 데이터를 다운스트림으로 푸시
  - onBackPressureError : 다운스트림 컨슈머가 처리를 계속 유지할 수 없으면 게지사는 오류를 발생

- 또한 속도를 제한하여 back pressure를 관리할 수도 있다.
  - limitRate(n) : 다운스트림 수요를 n보다 크지 않은 작은 규모로 나눔.
  - limitRequest(n) : 다운스트림 컨슈머의 수요를 제한할 수 있음


#### hot 스트림과 cold 스트림

- Reactive Publisher에 대해 이야기할 때 hot, cold 두 가지 유형으로 분류 할 수 있다.

- cold publisher : **구독자가 나타날 때마다 데이터를 처음부터 다시 생성하는 스트림**. 구독자 없이는 데이터가 생성되지 않음

  - 예시로는 온라인 쇼핑 사이트에서의 HTTP 요청이 있다. 사용자가 상품 목록을 요청할 때,  해당 요청에 맞는 상품 데이터를 처음부터 생성하여 응답하게 되는데, 각 사용자는 상품 목록을 요청할 때마다 새로운 데이터를 얻게 될 것이다. 

  ~~~java
  Flux<String> coldPublisher = Flux.defer(() -> { //defer을 통해 cold publisher 생성
    log.info("Generating new items");
    return Flux.just(UUID.randomUUID().toString()); // 구독자마다 다른 id를 가지게 됨
  });
  
  log.info("No data was generated so far"); 
  coldPublisher.subscribe(e -> log.info("onNext: {}", e)); 
  coldPublisher.subscribe(e -> log.info("onNext: {}", e));
  log.info("Data was generated twice for two subscribers");
  ~~~

- hot publisher : **데이터 생성이 구독자의 존재 여부에 의존하지 않음**. 구독자가 나타날 시 이전에 생성된 값을 보내지 않고 새로운 값만 보낼수도 있음.
  - 예시로는 주식 시장에서 실시간 주식 가격 데이터이다. 주식 가격 데이터는 미리 생성되고, 여러 구독자들에게 동시에 발행되고, 구독자들은 현재 가격 데이터를 받게 된다.
- 팩토리 메서드 just를 통해 publisher가 생성될 때 값이 한 번만 계산되고 새 구독자가 도착하면 다시 계산되지 않는 형태의 hot pusblisher를 생성.
- just는 defer로 래핑해 hot publisher를 cold publisher로 전환 할 수 있음

#### 스트림 원소를 여러 곳으로 보내기

- 반대로 cold publisher를 hot publisher로 전환도 가능함

  - cold publisher의 결과를 데이터 생성 준비가 완료되는 대로 일부 구독자에게 공유하는 경우

- 각 구독자를 위해 중복된 데이터를 생성하지는 않으려고 하며, 이러한 용도로 ConnectableFlux가 있음.

- ConnectableFlux를 이용하면 가장 수요가 많은 데이터를 생성하고 다른 모든 가입자가 데이터를 처리할 수 있도록 캐싱

  ~~~java
  Flux<Integer> source = Flux.range(0, 3)
    	.doOnSubscribe(s -> log.info("new subscription for the cold publisher"));
  
  ConnectableFlux<Integer> conn = source.publish();
  
  conn.subscribe(e -> log.info("[Subscriber 1] onNext: {}", e));
  conn.subscribe(e -> log.info("[Subscriber 2] onNext: {}", e));
  
  log.info("all subscribers are ready, connecting");
  conn.connect(); //데이터 발행 시작
  ~~~

#### 스트림 내용 캐싱하기

- cache 연산자를 통해 이벤트 캐싱이 가능하다.

  ~~~java
  Flux<Integer> source = Flux.range(0, 2)
  	.doOnsubscribe(s -> log.info("new subscription for the cold publisher"));
  Flux<Integer> cachedSource = source.cache(Duration.ofSeconds(1)); // 1초 동안 캐시
  cachedSource.subscribe(e -> log.info("[S 1] onNext: {}", e)); 
  cachedSource.subscribe(e -> log.info("[S 2] onNext: {}", e));
  Thread.sleep(1200); // 캐시된 데이터가 만료됨.
  cachedSource.subscribe(e -> log.info("[S 3] onNext: {}", e)); //캐시가 없기에, 재구독 진행
  ~~~

#### 스트림 내용 공유

- ConnectableFlux를 사용해 여러 개의 구독자에 대한 이벤트를 멀티캐스트함.

- share 연산자를 이용하면 cold publisher를 hot publisher로 변환할 수 있다.

  - 구독자가 각 신규 구독자에게 이벤트를 전파하는 방식으로 작동

  ~~~java
  Flux<Integer> source = Flux.range(0, 5) 
    .delayElements(Duration.ofMillis(100)) 
    .doOnSubscribe(s -> log.info("new subscription for the cold publisher"));
  
  Flux<Integer> cachedSource = source.share();
  cachedSource.subscribe(e-> log.info("[S 1] onNext: {}", e)); 
  Thread.sleep(400);
  cachedSource.subscribe(e-> log.info("[S 2] onNext: {}", e));
  //2번째 구독자는 자신이 생성되기 전에 발생한 이벤트는 수신하지 못함
  ~~~

#### 시간 다루기

- interval : 주기적으로 이벤트 생성

- delayElements : 원소를 지연

- delaySequence : 모든 신호를 지연

  ~~~java 
  // elapsed : 이전 이벤트와의 시간 간격 측정
  Flux.range(0,5)
    	.delayElements(Duration.ofMillis(100))
    	.elapsed()
    	.subscribe(e -> log.info("Elapsed {} ms: {}", e.getT1(), e.getT2()));
  ~~~

#### 리액티브 스트림을 조합하고 변환하기

- 복잡한 리액티브 워크플로를 구축할 때 종종 서로 다른 위치에서 동일한 순서의 연산자를 사용해야 할 때가 있다.

- transform 연산자와 compose 연산자를 이용해 데이터 스트림을 변환하여 별도의 객체로 추출할 수 있다. -> 재사용성!!

  - transform : 각각의 구독마다 새로운 Publisher를 생성함. **구독자마다 다른 변환 로직을 적용하고 싶을 때** 사용
  - compose : 원래의 스트림에 동일한 변환을 적용하여 새로운 Publisher를 생성함. **모든 구독자에게 동일한 변환을 적용하고 싶을 때** 사용

  ~~~java
  Function<Flux<String>, Flux<String>> logUserInfo = 
    stream -> stream.index() //수신 이벤트를 열거형으로 전환. return 값은 Flux<Tuple2<Long, String>>
    								.doOnNext(tp -> log.info("[{}] User: {}", tp.getT1(), tp.getT2()))
    								.map(Tuple2::getT2);
  
  Flux.range(1000, 3)
  		.map(i -> "user-" + i) 
    	.transform(logUserInfo)
  		.subscribe(e -> log.info("onNext: {}", e));
  ~~~

  ~~~java
  Function<Flux<String>, Flux<String>> logUserInfo = stream -> { 
    if(random.nextBoolean()) {
  		return stream.doOnNext(e -> log.info("[path A] User: {}" e));
    } else {
  		return stream.doOnNext(e -> log.info("[path B] User: {}", e));
    }
  };
  
  Flux<String> publisher = Flux.just("1", "2")
    													 .compose(logUserInfo);
  publisher.subscribe();
  publisher.subscribe();
  ~~~

#### Processor

- 리액티브 스트림 스펙은 Processor 인터페이스를 정의는 하고 있음.
- Processor는 Publisher이며 Subscriber.
- 리액터 개발팀은 Processor를 사용 어려움 및 오류 가능성의 이유로 사용하지 않을 것을 권장하고 있음
- 리액터의 프로세서들은 생략...

#### 리액터 프로젝트 테스트 및 디버깅하기

- io.projectreactor:reactor-test 라이브러리는 리액터 프로젝트로 구현된 리액티브 워크플로를 테스트하는 데 필요한 모든 도구를 제공함.
- 리액티브 코드가 디버깅하기가 쉽지는 않지만, 이에 조립 단계에서 적용 가능한 디버깅 기능을 제공한다.
- Hooks.onOperatorDebug(); -> 조립할 모든 스트림에 대해 stackTrace를 수집함(비용 많이 듬)
- Flux, Mono는 제공하는 **log** 메서드 -> 매개변수를 이용해 customize 가능하고, 여러 상황에서 필요한 데이터 추적 가능

#### 리액터 추가 기능

- 리액터 Addons 프로젝트에는 Reactor 프로젝트를 위한 몇 가지 module이 있음.
  - reactor-adapter : RxJava 2 Reactive type 및 scheduler에 대한 adapter 제공, akka와의 통합 허용
  - reactor-logback : 고속의 비동기 로깅 제공. AsyncAppender 기반
  - reactor-extra : 고급 기능을 위한 여러 추가 유틸리티가 있음.
    - TupleUtils 클래스, MathFlux 클ㄹ래스, ...
- 비동기 프레임워크 및 메시지 브로커에 대한 리액티브 드라이브가 있음
  - Reactor RabitMQ - reactive java client 제공. Back pressure 지원, 비동기 논블로킹 메시지 처리 가능
  - Reactor Kafka Module - kafka message broker와 유사한 기능 제공
  - Reactor Netty - netty의 TCP/HTTP/UDP client와 server에서 사용할 수 있게 해줌

### 리액터 프로젝트 심화학습

- 이제 수명 주기, 멀티스레딩, 내부 최적화 방식에 대해 알아보자.

#### 리액티브 스트림의 수명 주기 -> 여기 좀 어려움;

##### 조립 단계

- 학습했듯이, 리액터는 복잡한 처리 흐름을 구현할 수 있는 연쇄형 API를 제공함.

- 빌더 API처럼 보이지만, 차이점은 리액터 API는 불변성(Immutability)을 제공함. -> 각각의 연산자가 새로운 객체를 생성

- 조립(assembling) : 리액티브 라이브러리에서 실행 흐름을 작성하는 프로세스

  ~~~java
  Flux<Integer> sourceFlux = new FluxArray(1, 20, 300, 4000); 
  Flux<String> mapFlux = new FluxMap(sourceFlux, String::value0f); 
  Flux<String> filterFlux = new FluxFilter(mapFlux, s -> s.length() > 1);
  
  //의사 코드 just -> map -> filter
  FluxFilter( 
    FluxMap(
  		FluxArray(1, 20, 300, 4000)
  	)
  )
  ~~~

- stream 수명 주기에서 조립 단계가 중요한 이유는 stream의 타입을 확인해 연산자를 서로 바꿀 수 있기 때문?

  ~~~java
  public final Flux<T> concatWith(Publisher<? extends T> other) {
    if (this instanceof FluxConcatArray) {
      @SuppressWarnings({"unchecked"})
      FluxConcatArray<T> fluxConcatArray = (FluxConcatArray<T>) this;
      
      return fluxConcatArray.concatAdditionalSourceLas(other);
    }
    return concat(this, other);
  }
  ~~~

- 조립 단계에 대한 최종 정리 : stream 구성을 조작하고 리액티브 시스템을 구축하는 데 필수적인 디버깅 최적화나 모니터링, 더 나은 스트림 전달을 위한 다양한 기술을 적용할 수 있는 단계

###### 구독 단계

- 구독은 특정 Publisher를 구독할 때 발생
- 실행 플로를 만들기 위해 내부적으로 Publisher를 다른 Publisher에게 전달하는데, 일련의 Publisher 체인이 있다고 할 수 있다.
- 이 단계에서 조립 단계와 동일한 최적화를 수행할 수 있으며, 멀티 스레딩을 지원하는 일부 연산자는 구독이 발생하는 작업자를 변경할 수 있음

###### 런타임 단계

- Publisher와 Subscriber 간에 실제 신호가 교환됨.(onSubscribe 시그널과 request 시그널)
- 런타임 단계가 중요한 이유는 런타임 중에 signal 교환량?을 줄이기 위한 최적화?를 적용할 수 있기 때문

#### 리액터에서 스레드 스케줄링 모델

- 리액터가 멀티스레딩 실행을 위해 제공하는 네 가지 연산자와 연산자 사이의 차이점을 알아보자.

##### publishOn 연산자

- 런타임 실행의 일부를 지정된 워커로 이동할 수 있게 해준다.

- Scheduler : 리액터 프로젝트에서 worker 또는 worker pool을 나타내는 인터페이스. 스트림에 대한 특정 워커를 선택하는 용도로 사용됨.

  ~~~java
  Scheduler scheduler = ...;
  
  //main thread
  Flux.range(0,100)
    	.map(String::valueOf)
    	.filter(s -> s.length() > 1)
    
    	.publishOn(scheduler)
    	//scheduler thread(다른 worker에서 실행)
    	.map(this::calculateHash)
    	.map(this::doBusinessLogic)
    	.subscribe();
  ~~~

  <img src="/Users/seongjayong/Learning/book-spring-reactive/image/그림 4.9 리액터 publishOn 연산자의 내부 구조.png" alt="그림 4.9 리액터 publishOn 연산자의 내부 구조" style="zoom:30%;" />

  

  - publishOn 연산자는 내부적으로 전용 워커가 메시지를 하나씩 처리할 수 있도록 새로운 원소를 제공하는 큐를 가지고 있음.
  - 리액티브 스트림의 모든 원소는 하나씩 처리되므로 항상 모든 이벤트에 순서를 엄격하게 정의할 수 있음 -> 직렬성(serializability)
  - 위 그림만 봤을 때는 동시성이 없다고 느낄 수 있음. -> 처리 흐름의 병렬 처리를 가능하게 한 것.
  - 아래 두 그림을 비교해보자.

  <img src="/Users/seongjayong/Learning/book-spring-reactive/image/그림 4.10 리액티브 스트림에 대한 순수한 동기 처리.png" alt="그림 4.10 리액티브 스트림에 대한 순수한 동기 처리" style="zoom: 33%;" /> 

  <img src="/Users/seongjayong/Learning/book-spring-reactive/image/그림 4.11 publishOn 연산자에 의한 스트림 처리의 변화.png" alt="그림 4.11 publishOn 연산자에 의한 스트림 처리의 변화" style="zoom: 33%;" />

- 처리 단계 사이에 비동기 영역을 추가함으로써 병렬 처리를 이룰 수 있었음(처리 플로에서 왼쪽이 오른쪽의 프로세스 완료를 기다릴 필요가 없음)

##### subscribeOn 연산자

- 구독 체인에서 워커의 작업 위치를 변경할 수 있음

- 함수를 실행해 스트림 소스를 만들 때 유용하게 사용할 수 있음

  ~~~java
  ObjectMapper objectMapper = ...
  String json = "{\"color\" : \"Black\", \"type\" : \"BMW\" }"; 
  // Mono.fromCallable : Callable<T>에서 Mono를 생성하고 실행 결과를 각 구독자에게 전달
  Mono.fromCallable(()-> objectMapper.readValue(json, Car.class));
  ...
    
  public void subscribe(Subscriber actual) { 
    ...
  	Subscription subscription = ...;
    try {
  		T t = callable.call(); 
      if (t = null) subscription.onComplete(); 
  		else{
  			subscription.onNext(t); 
        subscription.onComplete();
      }
    }
    catch (Throwable e){ 
      actual.onError(
  				Operators.onOperatorError(e, actual.currentContext()));
    }
  }
  ~~~

  - 위 코드에서 publishOn을 사용하면 Callable이 실행될 워커를 지정 및 변경할 수 있다

    ~~~java
    Scheduler scheduler = ...; // 지정을 원하는 worker
    Mono.fromCallable(...)
      	.subscribeOn(scheduler) // 구독을 수행할 워커 지정
      	.subscribe();
    ~~~

##### parallel 연산자

- 하위 스트림에 대한 플로 분할과 분할된 플로 간 균형 조정 역할을 한다. -> 작업 분배

- 이용 시, ParallelFlux를 동작시킨다.

  - ParallelFlux : 다수의 Flux를 추상화한 것으로 Flux 간에 데이터의 크기가 균형을 이룸.

  ~~~java
  Flux.range(0, 10000)
    	.parallel() // Flux API의 일부임
    	.runOn(Schdulers.parallel())
    	.map()
    	.filter()
    	.subscribe();
  ~~~

##### Scheduler

- Scheduler.schedule과 Scheduler.createWorker라는 두 가지 핵심 메서드를 가진 Interface
  - schedule method : Runnable 작업을 예약할 수 있음
  - createWorker method : Runnable 작업을 예약할 수 있는 Worker 인터페이스의 인스턴스를 제공
- Scheduler와 Worker 인터페이스의 차이점?
  - Scheduler Interface : 워커 풀을 나타냄
  - Worker Interface : Thread 또는 리소스를 추상화한 것
- 기본적으로 리액터는 스케줄러 인터페이스에 대한 주요한 세 가지 구현체를 제공함.
  - SingleScheduler : 모든 작업을 한 개의 전용 워커에 예약할 수 있음
  - ParallelScheduler : 고정된 크기의 worker pool에서 작동
  - ElasticScheduler  : 동적으로 worker를 만들고 스레드 풀을 캐시

#### 리액터 컨텍스트

- Context : 스트림을 따라 전달되는 인터페이스

- Context Interface의 핵심 아이디어는 나중에 런타임 단계에서 필요한 컨텍스트 정보에 액세스 할 수 있도록 하는 것

- 같은 일을 할 수 있는 ThreadLocal 대신에 왜 Context가 또 필요한지 궁금할 수도 있습니다.

- 대다수의 프레임워크는 ThreadLocal을 사용해 사용자 요청에 SecurityContext를 전달하고, 각 처리 지점에서 사용자의 액세스 권한이 적절한지 확인합니다.

  - threadlocal : 오직 한 쓰레드에 의해 읽고 쓰여질 수 있는 쓰레드만의 독립적인 로컬 변수

  - SecurityContext : Authentication 객체가 저장되는 보관소

  - 인증 후 스트림 처리가 단일 스레드에서 이루어지기 때문에  

  - Threadlocal 사용했을 때의 장점? 스레드 간 독립성 유지, 스레드 내 직접 접근으로 인한 성능 향상 등등

    <img src="https://oopy.lazyrockets.com/api/v2/notion/image?src=https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fabf1b3ea-a402-48bb-879c-bf099a25fabb%2F1.png&blockId=e5a25e72-1e6e-4cac-9901-bf25d6b5d13f" alt="img" style="zoom:30%;" />

- 허나 이는 단일 스레드 환경에서 이용할 때만? 제대로 동작하는 방식! -> 동기적 환경에서는 문제없다고 생각함

- 비동기 멀티 스레드 환경에서 제대로 동작하지 못함

  ~~~java
  class ThreadLocalProblemShowcase {
    public static void main(String[] args) { 
      ThreadLocalMap<Object, Object>> threadLocal = new ThreadLocal(); 
      threadLocal.set(new HashMap());
  
      Flux
  				.range(0, 10)
  				.doOnNext(k -> threadLocal.get()
                    								.put(k, new Random(k).nextGaussian()) //threadlocal 내부에 저장
  				.publishOn(Schedulers.parallel())  // 다른 스레드로 이동
      		.map(k-> threadLocal.get().get(k)) //NullPointerException!!
      		.blockLast();
    }
  }
  ~~~

- 이를 리액터 Context는 아래 코드와 같이 해결!

  ~~~java
  Flux.range(0, 10) 
    	.flatMap(k -> Mono.subscriberContext() // 현재 스트림의 Context에 access
          	   					.doOnNext(context -> {
  												Map<Object, Object> map = context.get("randoms"); 
              	          map.put(k, new Random(k).nextGaussian());
  											}) 
      									.thenReturn(k)
      )
    	.publishOn(Schedulers.parallel())
    	.flatMap(k ->
              Mono.subscribeContext()
              		.map(context -> {
                    Map<Object, Object> map = context.get("randoms");
                    return map.get(k);
                  })
      )
    	.subscriberContext(context -> context.put("randoms", new HashMap()))
    	.blockLast();
    
  ~~~

- Context는 본질적으로 Immutable 객체임을 생각하며 코딩해야한다.

- Subscriber가 스트림을 통해 추가 Context 객체를 전달하기 위해 리액터는 CoreSubscriber라는 특정 Subscriber 인터페이스 구현체를 사용한다.

  ~~~java
  interface CoreSubscriber<T> extends Subscriber<T> { 
    default Context currentContext() { //method를 통해 context 반환
  		return Context.empty();
  	}
  }
  ~~~

- subscriberContext 연산자는 다운스트림의 Context와 전달된 매개변수를 병합하는 방식으로 CoreSubscriber를 구현

- 이는 액세스 가능한 Context 객체가 스트림의 다른 지점에서는 동일한 객체가 아닐 수 있다는 것을 의미

  ~~~java
  void run() {
  	printCurrentContext("top") 
      .subscriberContext(Context.of("top", "context")) // Context 수정
  		.flatMap(_-> printCurrentContext("middle")) 
      .subscriberContext(Context.of("middle", "context")) 
      .flatMap(_-> printCurrentContext("bottom"))
  		.subscriberContext(Context.of("bottom", "context")) 
      .flatMap(_-> printCurrentContext("initial")) 
      .block();
  }
  
  void print(String id, Context context) {
    ...
  }
  
  Mono<Context> printCurrentContext(String id) {
  	return Mono
  				.subscriberContext()
  				.doOnNext(context -> print(id, context));
  }
  
  top 	  {	Context3{bottom=context, middle=context, top=context} }
  middle  { Context2{bottom=context, middle=context} }
  bottom  { Context1{bottom=context} }
  initial { Context0{} }
  ~~~

- 일반적으로 Context는 리액티브 시스템을 구축하기 위한 리액터 프로젝트를 사용하게 유인하는 킬러 기능

- 사용자 요청 처리 중에 특정한 상황을 처리하기 위한 기능을 구현하는 것처럼 각 요청에서 데이터에 엑세스해야 하는 경우에 유용함

- 특히 Spring Security에서 많이 사용!

### 프로젝트 리액터의 내부 구조

- 리액터 프로젝트 3버전의 핵심 개선 사항은 리액티브 스트림 수명 주기 및 연산자 융합이다.

#### 매크로 퓨전

- 주로 조립 단계에서 발생하며 연산자를 다른 연산자로 교체하는 것

  - 원소가 생성된 직후에 원소에 대한 실행을 다른 worker로 옮기는 예제

  ~~~java
  Flux.just(1)
    	.publishOn(...)
    	.map(...)
  // 다른 worker의 원소를 유지하기 위한 큐를 만들어야 하고, 그러한 큐에 원소를 입출력하기 위해 volatile 읽기 및 쓰기 발생
  // publishOn -> subscribeOn으로 치환 시 추가 큐를 만들 필요가 없음 (최적화!!)
  ~~~

- 일반적으로 리액터 프로젝트에 적용된 매크로 퓨전의 목적은 조립된 흐름을 최적화하는 것!!

#### 마이크로 퓨전

- 매크로 퓨전에 비해 좀 더 복잡한 최적화이며 런타임 최적화 및 공유 리소스 재사용과 관련 있음

  - 조건부 연산자 예제

    ~~~java
    Flux.from(factory)
      	.filter(inspectionDepartment) // 필터 연산자 같은 조건부 연산자가 전체 성능에 영향을 미칠 수 있음
      	.subscribe(store);
    // ConditonalSubscriber를 활용해 소스 측에서 조건을 바로 확인하고 추가적인 request 메서드 호출 없이 필요한 개수를 전송할 수 있음
    ~~~

  - 연산자 간 비동기 경계 관련 예제

    ~~~java
    Flux.just(1,2,3)
      	.publishOn(schedulers.parallel())
      	.concatMap(i -> Flux.range(0, i)
                  					.publishOn(Schedulers.parallel()))
    // 위 체인에는 두 개의 비동기경계가 포함됨
    // 1. concatMap 연산자. 업스트림에 들어오는 각 원소마다 n개의 원소를 생성할 수 있음
    // 2. publishOn 연산자. reactive stream의 원소를 다른 worker thread로 전송할 때 queue에 넣는 작업이 필요함
    ~~~

    - 경계 또는 경계 내부의 원소 체인에 공유 큐가 있다고 가정하고, 추가적인 request 메서드 호출 없이 업스트림 연산자가 큐를 사용하도록 연산자 체인 전체를 전환하면 전반적인 성능을 크게 향상시킬 수 있음

### 요약

- 리액티브 스트림 스펙 이후 리액터 프로젝트에서 무엇이 변경됐는지 살펴보았음
- Mono 및 Flux 리액티브 타입에 대해서도 알아봄
- 스트림 실행 내부 동작을 들여보았음
- 리액터 프로젝트 라이브러리는 리액티브 프로그래밍 및 비동기적인 I/O 집약적인 애플리케이션을 위한 강력한 도구!



