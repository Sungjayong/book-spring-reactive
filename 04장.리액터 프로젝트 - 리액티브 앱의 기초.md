## 04장. 리액터 프로젝트 - 리액티브 앱의 기초

- 리액터 프로젝트의 역사와 배경
- 리액터 프로젝트의 용어와 API
- 리액터 프로젝트의 고급 기능
- 리액터 프로젝트의 가장 중요한 구현 세부 정보
- 가장 자주 사용되는 리액티브 타입의 비교
- 리액터 라이브러리로 구현한 비즈니스 사례

### 리액터 프로젝트의 간략한 역사

#### 리액터 프로젝트 버전 1.x

- 리액터 패턴, 함수형 프로그래밍 및 리액티브 프로그래밍과 같은 메시지 처리에 대한 모범 사례를 통합하여 만들었음.

  - 리액터 패턴 : 모든 이벤트가 큐에 추가 되고 이벤트는 나중에 별도의 스레드에 의해 처리, 이벤트는 이벤트 핸들러로 발송되어 동기적으로 처리됨

  ~~~java
  Environment env = new Environment();
  //builder pattern
  Reactor reactor = Reactors.reactor()
    												.env(env)
    												.dispatcher(Environment.RING_BUFFER)
    												.get();
  //event handler 등록
  reactor.on($("channel"),
            event -> sout(event.getData())
  );
  //event producer 구성
  Executors.newSingleThreadScheduledExecutor()
    				.scheduleAtFixedRate(
    					() -> reactor.notify("channel", Event.wrap("test")),
    					0, 100, TimeUnit.MILLISECONDS
  );
  ~~~

  - 내부적으로, 이벤트는 Dispatcher에 의해 처리된 후 목적지로 보냄

  ~~~java
  ... // Environment, Reactor 인스턴스 생성
  Stream<String> stream = Streams.on(reactor, $("channel")); //특정 채널의 Stream 인스턴스를 받음
  stream.map(s -> "Hello world " + s)
  					.distinct()
  					.filter((Predicate<String>) s -> s.length() > 2) 
    				.consume(System.out::println);
  // Deferred class : stream에 수동으로 이벤트를 제공할 수 있는 특수한 래퍼 클래스
  Deferred<String, Stream<String>> input = Streams.defer(env);
  // compose method : Stream 인스턴스를 얻을 수 있음
  Stream<String> compose = input.compose(); 
  compose.map(m -> m + " Hello World") 
    		 .filter(m -> m.contains("1"))
  			 .map(Event::wrap) 
    		 .consume(reactor.prepare("channel"));
  // input에 랜덤하게 원소를 제공
  for(int i = 0; i < 1000; i++) { 
    input.accept(UUID.randomUUID().toString());
  }
  ~~~

  - 리액터 1.x의 단점
    - Back pressure 기능이 없음
    - 오류 처리의 복잡함

  #### 리액터 프로젝트 버전 2.x

  - 이벤트 버스 및 스트림 기능을 별도의 모듈로 추출
  - 리액티브 스트림 스펙을 완벽하게 준수하게 설계함
  - Back pressure 관리, 스레드 처리, 복원력 지원

  ~~~java
  stream
    	.retry()
    	.onOverflowBuffer() // back pressure 관리
    	.onOverflowDrop()
    	.dispatchOn(new RingBufferDispatcher("test"))
  ~~~

  - 추후 리액터 3.x 개발에 기반이 됨..!

### 리액터 프로젝트 필수 요소

- 비동기 파이프라인을 구축할 때, 콜백 지옥과 깊게 중첩된 코드를 생략하는 목적으로 설계
- "리액티브 응용 프로그램을 통해 처리된 데이터는 마치 조립 라인을 통해 이동하는 것과 유사하다. 리액터는 컨베이어 벨트와 워크스테이션 역할이라고 할 수 있다"
  - 라이브러리의 목표는 코드 가독성을 높이고 조합성(composability)를 가지는 것
  - 실행 그래프는 실행 흐름만 정의하지만, 구독자가 구독을 했을 때만 데이터 플로가 기동(lazy loading...!)
  - 비동기 요청의 결과를 효율적으로 처리할 수 있게 설계하였으며, 오류 처리 시 복원력 있는 코드를 작성할 수 있게 해줌.
- 라이브러리의 Back Pressure 모드 지원
  - 푸시 전용 : 구독자가 효과적으로 무한한 수를 요청
    - subscription.request(Long.MAX_VALUE)
  - 풀 전용 : 구독자가 이전 요소를 받은 후에만 다음 요소를 요청하는 경우
    - subscription.request(1)
  - 풀-푸시(혼합형) : 구독자가 수요를 실시간 제어할 수 있고 게시자가 데이터 소비 속도에 적응할 수 있는 경우

- 동시에 실행 스레드를 관리할 수 있는 유용한 스케줄러 세트를 제공

#### 프로젝트에 리액터 추가하기

- 의존성 추가
  - compile("io.projectreactor:reactor-core:3.2.0.RELEASE")
  - testCompile("io.projectreactor:reactor-test:3.2.0.RELEASE") SEENEL 192

#### 리액티브 타입 - Flux와 Mono

- 이전에도 말했듯이, 리액티브 스트림 스펙에는 Publisher<T>, Subscriber<T>, Subscription 및 Processor<T,R>의 네 가지 인터페이스만 정의되어 있음.
- 이 중 Publisher<T>의 구현체로 Flux<T>, Mono<T> 두 가지가 있음.

##### Flux

- 0, 1 또는 여러 요소를 생성할 수 있는 일반적인 리액티브 스트림을 정의

- 함수형 프로그래밍을 통해 무한대의 리액티브 스트림을 만들어 낼 수 있음

  ~~~java
  Flux.range(1,5).repeat() // 1,2,3,4,5,1,2,3,4,5,1,2,...
  //참고로, 이러한 무한 스트림 요소들을 모두 수집하려는 시도는 OutOfMemoryError를 유발할 수 있다
  ~~~

  ~~~java
  Flux.range(1, 100)
    	.repeat()
    	.collectList() // 모든 요소를 단일 리스트로 만듬
    	.block(); // 구독 기동 및 최종 결과가 도착할 때까지 실행 중인 스레드 차단
  ~~~

##### Mono

- 최대 하나의 요소를 생성할 수 있는 스트림

- 버퍼 중복과 값비싼 동기화 작업을 생략하기 때문에 효율적으로 사용 가능

- **응용 프로그램 API가 최대 하나의 원소를 반환하는 경우 유용함**

- CompletableFuture -> 반드시 반환값 반환, 즉시 처리 시작

- Mono -> 구독자가 나타나야만 작업 수행, 리액티브 연산자 제공

- onComplete(), onError() 와 같이 처리 결과를 반환 가능

- Mono와 Flux는 서로 쉽게 변환할 수 있음

  ~~~java
  Mono.from(Flux.from(Mono)) //from을 통해 변환
  ~~~

- RxJava 2 버전을 위한 타입들이 있지만, 우리가 사용하지 않을 것이고 레거시도 없기에 생략..

#### Flux와 Mono 시퀀스 만들기

- Flux 및 Mono는 데이터를 기반으로 리액티브 스트림을 생성하는 많은 팩토리 메서드를 제공
- 어차피 다 기억하지 못할거기에, 이런 메서드가 있다는거만 보고 추후 사용 시에 아래 URL 참조
  - http://projectreactor.jo/docs/core/release/reference/#which-operator


~~~java 
Flux<String> stream1 = Flux.just("Hello", "world");
Flux<Integer> stream2 = Flux.fromArray(new Integer[]{1, 2, 3}); // 객체 및 컬렉션에서 참조 가능
Flux<Integer> stream3 = Flux.fromIterable(Arrays.asList(9,8,7));
Flux<Integer> stream4 = Flux.range(2010, 9);

Mono<String> stream5 = Mono.just("One");
Mono<String> stream6 = Mono.justOrEmpty(null);
Mono<String> stream7 = Mono.justOrEmpty(Optional.empty());

Mono<String> stream8 = Mono.fromCallable(() -> httpRequest());
Mono<String> stream8 = Mono.fromCallable(this::httpRequest);

// 빈 스트림과 오류만 포함하는 스트림
Flux<String> empty = Flux.empty();
Flux<String> never = Flux.never(); // 완료 메시지, 데이터, 오류에 대해서도 신호를 보내지 않는 스트림
Mono<String> error = Mono.error(new RuntimeException("Unknown id")); // 각 구독자에 onError() 메서드를 통해 항상 오류를 전파하는 시퀀스 생성

// 1! -> 실제 구독이 발생해야 유효성 검사를 함
Mono<User> requestUserData(String sessionId) { 
  // defer : 구독하는 순간에 행동을 결정하는 시퀀스
  return Mono.defer(()->
			isValidSession(sessionId)
			? Mono.fromCallable(() -> requestUser(sessionId))
			: Mono.error(new RuntimeException("Invalid user session")));
}

// 2! -> 메서드 호출 시 유효성 검사 실행
Mono<User>requestUserData(String sessionId){ 
  return isValidSession(sessionId)
			? Mono.fromCallable(() -> requestUser(sessionId))
			: Mono.error(new RuntimeException("Invalid user session"));
}

~~~

#### 리액티브 스트림 구독하기

~~~java
subscribe();
subscribe(Consumer<T> dataConsumer);
subscribe(Consumer<T> dataConsumer, Consumer<Throwable> errorConsumer);
subscribe(Consumer<T> dataConsumer, Consumer<Throwable> errorConsumer,
Runnable completeConsumer);
// 적절한 양의 데이터를 요구 -> 구독 제어
subscribe(Consumer<T> dataConsumer, Consumer<Throwable> errorConsumer,
Runnable completeConsumer, Consumer<Subscription> subscriptionConsumer);

subscribe(Subscriber<T> subscriber);

// example
Flux.just("A", "B", "C")
  .subscribe(
		data -> log.info("onNext: {}", data),
  	err -> { /* ignored */ },
  	() -> log.info("onComplete")
);

// example 2
Flux.range(1, 100) 
  	.subscribe(
				data -> log.info("onNext: {}", data), 
  			err -> { /* ignore */ },
				() - > log.info("onComplete"), 
  			subscription -> { //구독 제어!!
          subscription.request(4); 
          subscription.cancel();
        }
);
~~~

- Disposable 인스턴스를 취소용으로 사용할 수 있다

  ~~~java
  Disposable disposable = Flux.interval(Duration.ofMillis(50)) 
    		.subscribe(
  					data -> log.info("onNext: {}", data) 
  			);
  Thread.sleep(200); 
  disposable.dispose(); // 구독 취소
  ~~~

#### 사용자 정의 Subscriber 구현하기

- 리액티브 스트림 스펙에 따라 Subscriber 인터페이스를 직접 구현할 수 있음

  ~~~java
  Subscriber<String> subscriber = new Subscriber<String>() {
    volatile Subscription subscription;
    
    public void onSubscribe(Subscription s) {
      subscription = s;
      log.info("initial request for 1 element");
    }
    
    public void onNext(String s) {
      log.info("onNext: {}", s);
      log.info("requesting 1 more element");
      
      subscription.request(1); // pull model
    }
    
    public void onComplete() {
      log.info("onComplete");
    }
    
    public void onError(Throwable t) {
      log.warn("onError: {}", t.getMessage());
    }
  };
  
  Flux<String> stream = Flux.just("Hello", "world", "|");
  stream.subscribe(subscriber);
  ~~~

- 하지만, 위와 같이 구독을 정의하면 스스로 BackPressure를 관리해야하고 가입자에 대한 모든 TCK 요구사항을 올바르게 구현해야 함

- 이에, 리액터 프로젝트에서 재공하는 BaseSubscriber 클래스를 상속하는게 훨씬 더 좋은 방법임

- 특히 구독자 자체가 세심한 라이프 사이클 관리가 필요한 resource를 포함하는 경우에 바람직함

  ~~~java
  class MySubscriber<T> extends BaseSubscriber<T> {
  public void hookOnSubscribe(Subscription subscription) {
  	log.info("initial request for 1 element"); request(1);
  }
  public void hookOnNext(T value) {
   	log.info("onNext: {}", value);
  	log.info("requesting 1 more element"); 
    request(1); // subscription.request가 아닌 자체의 BaseSubscriber의 request 사용
  }
  ~~~

### 연산자를 이용해 리액티브 시퀀스 변환하기

- 리액티브 시퀀스를 이용해 작업할 때는 스트림을 생성, 소비하는 것 외에도 스트림을 완벽하게 **변환하고 조작**할 수 있어야 함
- 이러한 변화 도구들은 일반적으로 아래와 같이 분류 가능
  - 기존 시퀀스 변환
  - 시퀀스 처리 과정을 살펴보는 메서드
  - Flux 시퀀스를 분할 또는 결합
  - 시간을 다루는 작업
  - 데이터를 동기적으로 반환

#### 리액티브 시퀀스의 원소 매핑하기

~~~java
// map(Function<T,R>) : 원소를 하나씩 처리
// cast(Class c) : 스트림 요소를 대상 클래스 타입으로 형변환
public final <E> Flux<E> cast(Class<E> clazz) {
  return map(clazz::cast);
}

Flux.range(2018,5)
  	.timestamp() // 현재 timestamp를 추가해 Tuple로 전환 -> Flux<Tuple2<Long, Integer>>
  	.index()     // 열거형으로 전환 -> Flux<Tuple2<Long, Tuple2<Long, Integer>>>
  	.subscribe(e -> log.info("index: {}, ts: {}, value: {}",
        e.getT1(),
        Instant.ofEpochMilli(e.getT2().getT1()),
        e.getT2().getT2()));
~~~

#### 리액티브 시퀀스 필터링하기

~~~java
// filter : 조건 만족하는 요소만 통과
// ignoreElements : Mono<T>를 반환하고 어떤 원소도 통과시키지 않음
// take(n) : n개의 원소만 유입
// takeLast : 마지막 원소만 반환
// takeUntil(Predicate) : 어떤 조건이 만족될 때까지 원소를 전달
// elementAt(n) : n번째 원소만 가져옴
// skip(Duration), take(Duration) : 특정 시간까지 원소를 가져오거나 건너 뜀
// single : 단일 항목을 내보냄

Mono<?> startCommand = ...
Mono<?> stopCommand = ... 
Flux<UserEvent> streamOfData = ...
  
streamOfData 
  .skipUntil0ther(startCommand) //startCommand가 오기 전까지 skip  
  .takeUntil0ther(stopCommand)  //stopCommand가 올 때까지 유입
  .subscribe(System.out::println);
~~~

#### 리액티브 시퀀스 수집하기

- 시퀀스 원소를 수집하는 행위는 자원을 부족하게 할 수 있음을 고려해야 함

~~~java
Flux.just(1,6,2,8,3,1,5,1)
  	.collectSortedList(Comparator.reverseOrder()) // Flux를 Mono type 스트림으로 처리하면서, 정렬도 가능
  	.subscribe(System.out::println);
//defaultIfEmpty(T) : 스트림이 비어 있으면 기본값을 반환
//Flux.distinct() : 입력 시퀀스의 중복을 제외하고 전달
~~~

#### 스트림의 원소 줄이기

~~~java
// Flux.any(Predicate) : 하나 이상의 원소에 원하는 속성이 있는지 확인
// hasElements, hasElement : 특정 원소 존재하는지 확인. 후자는 원소가 발견되는 즉시 true 반환
Flux.just(3,5,7,9,11,15,16,17)
  	.any(e -> e % 2 == 0)
  	.subscribe(hasEvenes -> log.info("Has evens: {}", hasEvens));

Flux.range(1, 5)
  	.reduce(0, (acc, elem) -> acc + elem)
  	.subscribe(result -> log.info("Result: {}", result)); // 15. 결과 하나만 출력
Flux.range(1, 5)
  	.scan(0, (acc, elem) -> acc + elem)
  	.subscribe(result -> log.info("Result: {}", result)); // 매번 연산 과정 출력

// then, thenMany, thenEmpty : 들어오는 원소를 무시하고 완료 및 오류 신호만 보냄
Flux.just(1,2,3)
  	.thenMany(Flux.just(4,5)) // 1,2,3은 무시하고 4,5만 전송
  	.subscribe(e -> log.info("onNext: {}", e));
~~~

#### 리액티브 스트림 조합하기

- 여러 개의 입력 스트림을 하나의 출력 스트림으로 결합해주는 연산자들이 있음

~~~java
// concat : 모두 연결해 다운스트림으로 전달
// merge : concat 연산자와 달리 업스트림 소스는 각각 별개로 구독됨
// zip : 모든 업스트림을 구독하고 모든 소스에서 하나의 원소를 받아 출력 원소로 결합
Flux.concat(
	Flux.range(1,3),
	Flux.range(4,2),
	Flux.range(6,5)
).subscribe(e -> log.info("onNext: {}", e)); // 1,2,3,...,10
~~~

#### 스트림 내의 원소 일괄 처리하기

~~~java
Flux.range(1,13)
  	.buffer(4) // 컬렉션을 통해 요청 횟수를 줄일 수 있음
  	.subscribe(e-> log.info("onNext: {}", e));
// 결과 : [1,2,3,4] [5,6,7,8] [9,10,11,12] [13]
~~~

~~~java
Flux<Flux<Integer>>> windowedFlux = Flux.range(101, 20)
  .windowUntil(this::isPrime, true);

windowedFlux.subscribe(window -> window
                      .collectList() // Mono<List<Integer>>로 타입 변환
                      .subscribe(e -> log.info("window: {}", e)));
// 결과 : [101,102] [103,104,105,106] [107,108] [109,110,111,112]
//       [113,114,115,116,117,118,119,120]
~~~

~~~java
//groupBy : 리액티브 스트림의 원소를 몇 가지 기준으로 그룹화
Flux.range(1,7)
  	.groupBy(e -> e % 2 == 0 ? "Even" : "Odd") // Flux<GroupedFlux<String, Integer>>
  	.subscribe(groupFlux -> groupFlux
          .scan(
          		new LinkedList<>(),
          		(list, elem) -> {
                list.add(elem);
                if(list.size() > 2) {
                  list.remove(0);
                }
                return list;
              })
          .filter(arr -> !arr.isEmpty())
          .subscribe(data -> log.info("{}: {}"), groupFlux.key(), data))
  );

Odd: [1] Even: [2] Odd: [1, 3] Even: [2, 4] Odd: [3, 5] Even: [4, 6] Odd: [5, 7]

~~~

#### flatMap, concatMap, flatMapSequential 연산자

- flatMap 연산자는 논리적으로 map 과 flatten 의 2가지 작업으로 구성됨
  - map 파트 : 들어오는 각 원소를 리액티브 스트림(T -> Flux<R>)으로 변환
  - flatten 파트 : 생성된 모든 리액티브 시퀀스를 R 타입의 원소를 통과시키는 새로운 리액티브 시퀀스로 병합 

- 사용자가 좋아하는 책을 확인하는 간단한 알고리즘을 예를 들어보자.

  ~~~java
  // 특정 user의 좋아하는 책 질의
  public Flux<String>requestBooks(String user) { 
    return Flux.range(1, random.nextInt(3) + 1)
  							.map(i -> "book-" + i) 
      					.delayElements(Duration.ofMillis(3));
  }
  
  // requestBooks 메서드 실행
  Flux.just("user-1", "user-2", "user-3") 
    	.flatMap(u -> requestBooks(u).map(b -> u+ "/" + b))
  		.subscribe(r -> log.info("onNext: {}", r));
  
  [thread: parallel-3] onNext: user-3/book-1 
  [thread: parallel-1] onNext: user-1/book-1 
  [thread: parallel-1] onNext: user-2/book-1 
  [thread: parallel-4] onNext: user-3/book-2 
  [thread: parallel-5] onNext: user-2/book-2 
  [thread: parallel-6] onNext: user-1/book-2 
  [thread: parallel-7] onNext: user-3/book-3
  [thread: parallel-8] onNext: user-2/book-3
  ~~~

  - flatMap 연산자의 출력이 다른 스레드의 구독자 핸들러에 도착한다
  - 이벤트들 사이의 **발생 순서(the happens-before semantics)**를 보장
  - flatMap 연산자는 한 줄의 코드로 복잡한 워크플로를 구현할 수 있다!! => Functional Programming, Reactive Programming 모두에서 중요함.
  - [참고] map vs flatMap (www.baeldung.com/java-reactor-map-flatmap)
    - Similar to *map*, the *flatMap* operator has a single parameter of type *Function*. However, unlike the function that works with *map*, the *flatMap* mapper function **transforms an input item into a Publisher** rather than an ordinary object.
    - **The map operator applies a one-to-one transformation to stream elements, while flatMap does one-to-many**.
    - [*map*](https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#map-java.util.function.Function-): Transform the items emitted by this *Flux* by applying a synchronous function to each item
    - [*flatMap*](https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#flatMap-java.util.function.Function-): Transform the elements emitted by this *Flux* asynchronously into *Publishers*

#### 샘플링하기

- 원하는 한도 내에서 일부 이벤트만 처리할 때 사용

  ~~~java
  Flux.range(1, 100)
  		.delayElements(Duration.ofMillis(1)) 
    	.sample(Duration.ofMillis(20)) //주기적 출력!
    	.subscribe(e -> log.info("onNext: {}", e));
  // 13, 28, 43, 58, 73, 89, 100
  ~~~

#### 리액티브 시퀀스를 블로킹 구조로 전환하기

- 리액터 프로젝트 라이브러리는 리액티브 시퀀스를 Blocking 구조로 변환하기 위한 API를 제공함.

- Reactive가 추구하는 바와 Blocking 처리는 거리가 멀지만, 상위 API에서 필요로 하는 경우가 있기에 설정이 가능함.

  ~~~java
  // toIterable : Flux를 Blocking Iterable로 변환
  // toStream : Flux를 Blocking Stream API로 변환
  // blockFirst : 업스트림이 첫 번째 값을 보내거나 완료될 때까지 현재 스레드 차단
  // blockLast : 업스트림이 마지막 값을 보내거나 완료될 때까지 현재 스레드 차단
  ~~~

#### 시퀀스를 처리하는 동안 처리 내역 살펴보기

- 프로세스 파이프라인의 중간에 있는 각 원소나 특정 시그널을 처리해야 하는 경우가 있음

  ~~~java
  // doOnNext(Consumer <T>) : Flux나 Mono의 각 원소에 대한 어떤 액션을 수행할 수 있게 해 줌
  // doOnComplete(), doOnError(Throwable) : 대응 이벤트 발생 시에 호출
  // 모든 신호를 처리하는 doOnEach(Consumer<Signal>) 메서드
  Flux.just(1,2,3)
    	.concatWith(Flux.error(new RuntimeException("Conn error")))
    	.doOnEach(s -> log.info("signal: {}", s))
    	.subscribe();
  
  // 모든 시그널을 수신!
  signal: doOnEach_onNext(1)
  signal: doOnEach_onNext(2)
  signal: doOnEach_onNext(3)
  signal: onError(java.lang.RuntimeException: Conn error)
  ~~~

- ❓doOnEach를 왜 써야해? 그냥 subscribe 시에 매개변수로 넣어주면 되는거 아냐?
- ❗️https://stackoverflow.com/questions/56604767/what-is-the-different-between-using-the-dooneach-onerror-oncomplete-within-sub => subscription을 통제할 수 없는 경우라거나, 위에서 말한대로. 그리고 아래 코드처럼 파이프라인의 중간에 있는 원소를 처리할 때 필요함!

#### 데이터와 시그널 변환하기

- 데이터 스트림을 시그널 스트림으로 변환, 역변환이 필요할 때가 있음

  ~~~java
  Flux.range(1,3)
    .doOnNext(e -> log.info("data : {}", e))
    .materialize()
    .doOnNext(e -> log.info("signal: {}", e))
    .dematerialize()
    .collectList()
    .subscribe(r -> log.info("result: {}", r));
  
  // result
  data :1 
  signal: onNext(1) 
  data :2 
  signal: onNext(2) 
  data :3 
  signal: onNext(3)
  signal: onComplete() 
  result: [1, 2, 3]
  ~~~

### 코드를 통해 스트림 만들기

- 때로는 스트림 내에서 시그널을 생성하거나 객체의 라이프 사이클을 리액티브 스트림의 라이프 사이클에 바인딩하는? 보다 복잡한 방법이 필요함
- 리액터를 이용해 스트림을 프로그래밍 방식으로 생성하는 방법을 알아보자

#### 팩토리 메서드 - push와 create

- 단일 스레드 생성자를 적용해 Flux 인스턴스를 프로그래밍 방식으로 생성할 수 있음
- push : Flux를 생성하고, 데이터를 수동으로 하나씩 추가하는 방식으로 스트림을 만든다.

~~~java
Flux.push(emitter -> 
          IntStream.range(2000,3000) // FluxSink 타입 전송
         						.forEach(emitter::next) 
         						.delayElements(Duration.ofMillis(1)) // BackPressure 시뮬레이션
         						.subscribe(e -> log.info("onNext: {}", e)); // onNext 이벤트 구독
~~~

- push 팩토리 메서드는 기본 BackPressure 및 취소 전략을 사용해 비동기 API 적용 시 유용하게 사용할 수 있음
- create : push와 비슷하게 동작함. 데이터 생성을 개발자가 제어하면서 비동기적인 데이터 스트림 생성

~~~java
Flux<Integer> customFlux = Flux.create(emitter -> {
    emitter.next(1);
    // 비동기적으로 데이터를 생성하거나 외부 이벤트에 응답하여 데이터를 발행할 수 있습니다.
    someAsyncMethod((result) -> {
        emitter.next(result);
        emitter.complete();
    });
});
//추가적인 핸들러를 등록해 리소스 정리를 활성화시킬수도 있음
Flux.create(emitter -> {
  emitter.onDispose(() -> log.info("Disposed")); //Flux의 구독이 취소될 때 처리할 로직
})
  .subscribe(e -> log.info("onNext: {}", e));
~~~

#### 팩토리 메서드 - generate

- generate : 메서드를 호출하는 오브젝트의 내부 전달 상태를 기반으로 복잡한 시퀀스를 만들 수 있도록 설계

  ~~~java
  // 1st argument : 초깃값
  // 2nd argument : 진행 로직
  Flux.generate(
      () -> Tuples.of(0L, 1L),
      (state, sink) -> {
        log.info("generated value: {}", state.getT2()); 
        sink.next(state.getT2());
        long newValue = state.getT1() + state.getT2(); 
        return Tuples.of(state.getT2(), newValue);
    })
    .delayElements(Duration.ofMillis(1)) 
    .take(7)
  	.subscribe(e-> log.info("onNext: {}", e));
  ~~~

  - 다음 새 값을 생성하기 전에 새 값을 동기적으로 구독자에게 전파

#### 일회성 리소스를 리액티브 스트림에 배치

- using 팩토리 메서드를 사용해 일회성 리소스에 의존하는 스트림 생성할 수 있음

- **try-with-resources 방식**(try 종료 시 자동으로 자원 해제해주는 기능)의 접근법

  ~~~java
  Flux<String> ioRequestResults = Flux.using( 
    Connection::newConnection,
  	connection -> Flux.fromIterable(connection.getData()), 
    Connection::close
  );
  
  ioRequestResults.subscribe(
  	data -> log.info("Received data: {}", data), 
    e -> log.info("Error: {}", e.getMessage()),
  	()-> log.info("Stream finished")
  );
  
  // 성공 시
  IO Connection created 
  Received data: Some 
  Received data: data 
  IO Connection closed 
  Stream finished
  // 실패 시
  IO Connection created
  IO Connection closed
  Error: Communication error
  ~~~

#### usingWhen 팩토리를 사용해 리액티브 트랜잭션 래핑

- Using 연산자처럼 수동으로 자원을 관리할 수 있음

- using 연산자는 관리 자원을 동기적으로 검색하는 반면에 usingWhen 연산자는 관리되는 리소스를 리액티브 타입으로 검색

- 또한 usingWhen 연산자는 메인 스트림의 성공 및 실패에 대해 각각 다른 핸들러를 사용할 수 있음

- 즉, 완전한 Non-Blocking Reactive Transaction을 구현할 수 있음

  ~~~java
  Flux.usingWhen( 
    Transaction.beginTransaction(),
  	transaction -> transaction.insertRows(Flux.just("A", "B", "C")), 
    Transaction::commit,
  	Transaction::rollback
  ).subscribe(
    d -> log.info("onNext: {}", d),
  	e -> log.info("onError: {}", e.getMessage()),
  	() -> log.info("onComplete") 
  );
  ~~~

#### 에러 처리하기

- 최종 구독자가 onError 시그널에 대한 핸들러를 정의하지 않으면 onError는 UnsupportedOperationException을 발생시킴.
- onError 시그널을 받으면 시퀀스가 실행을 중지하나, 다른 방식으로 대응할 수 있음
  - onErrorReturn : 예외 발생 시 사전 정의된 정적 값 또는 예외로 계산된 값으로 대체 가능
  - onErrorResume : 예외를 catch하고 대체 워크플로 실행 가능
  - onErrorMap : 예외를 catch하고 상황을 더 잘 나타내는 다른 예외로 변환할 수 있음

~~~java
Flux.just("user-1") 
    .flatMap(user ->
      recommendedBooks(user)
        .retryBackoff(5, Duration.ofMillis(100)) //호출 실패 시 지수 백오프(Exponential backoff)로 재시도
        .timeout(Duration.ofSeconds(3))
        .onErrorResume(e -> Flux.just("The Martian"))) //보편적인 추천 영화 반환
    .subscribe(
      b -> log.info("onNext: {}", b),
      e -> log.warn("onError: {}", e.getMessage()), 
      () -> log.info("onComplete")
  	);
~~~

- 이렇듯, 리액터 프로젝트는 예외 처리를 돕고 응용프로그램의 복원력을 향상시키는데 도움이 되는 다양한 도구를 제공

#### BackPressure 다루기

- Reactive stream 스펙에서 프로듀서와 컨슈머 간의 의사소통에 Backpressure가 필요하지만 컨슈머에서 오버플로가 발생할 가능성은 여전히 존재함





