## 03장. 스트림의 새로운 표준 - 리액티브 스트림

- 일반적인 API 문제
- 배압 제어 문제
- 리액티브 스트림 예제
- 기술 호환성 문제
- JDK 9 내부의 리액티브 스트림
- 반응성 스트림의 고급 개념
- 리액티브 전망의 강화
- 리액티브 스트림의 실제 작동

### 모두를 위한 반응성

#### API 불일치 문제

- 과도하게 많은 선택지는 시스템을 지나치게 복잡하게 만들 수 있다

#### 풀 방식와 푸시 방식

- 리액티브 초기 단계 : 소스 -> 구독자 푸시 방식
- 거대한 데이터 목록을 필터링해서 최초 10개의 데이터만 가져오는 필터를 만든다 하자

~~~java
//pull 방식
final AsyncDatabaseClient dbClient = ...; //외부 DB 연결

public CompletionStage<Queue<Item>> list(int count) {
  BlockingQueue<Item> storage = new ArrayBLockingQueue<>(count);
 	CompletableFuture<Queue<Item>> result = new CompletabaleFuture();
  
  pull("1", storage, result, count);
  
  return result;
}

void pull(String elementId, Queue<Item> queue,
         CompletableFuture resultFuture, int count) {
	dbClient.getNextAfterId(elementId) // 해당 elementId의 다음 Id를 가진 Item 가져옴.
    	.thenAccept(item -> {
        if(isValid(item)) { // filter
          queue.offer(item);
          
          if(queue.size() == count) {
            resultFuture.complete(queue);
            return;
          }
        }
        pull(item.getId(), queue, resultFuture, count);
      });
}
~~~

- 위 코드대로 실행하게 되면 서비스에서 DB로의 요청에 추가 시간이 소요된다.

  <img src="/Users/seongjayong/Learning/book-spring-reactive/image/그림 3.1 풀링 방식의 처리 흐름 예제.png" alt="그림 3.1 풀링 방식의 처리 흐름 예제" style="zoom:30%;" />

- 미래에 들어올 요청의 개수를 알지 못하므로 DB가 사전에 데이터를 생성할 수 없어서 대기 상태에 있게 됨.

- 1차 개선 : 풀링과 배치처리를 결합

  ~~~java
  void pull(String elementId, Queue<Item> queue, 
           CompletableFuture resultFuture, int count) {
    dbClient.getNextBatchAfterId(elementId, count) // Item을 count만큼 가져옴
      	.thenAccept(items -> {
          for(Item item : items) {
            if(isValid(item)) {
              queue.offer(item);
              
              if(queue.size() == count) {
                resultFuture.complete(queue);
                return;
              }
            }
          }
          pull(items.get(items.size() - 1).getId(), queue, resultFuture, count);
        });
  }
  ~~~

  <img src="/Users/seongjayong/Learning/book-spring-reactive/image/그림 3.2 배치 기반의 풀링 처리 예.png" alt="그림 3.2 배치 기반의 풀링 처리 예" style="zoom:30%;" />

  - 여전히 DB가 데이터 쿼리하는동안 클라이언트는 대기 상태.
  
  - 스트림을 통해 비동기적으로 푸시
  
    ~~~java
    public Observable<Item> list(int count) { //원소가 push됨?
      return dbClient.getStreamOfItems()
        						 .filter(item -> isValid(item))
        						 .take(count)
    }
    ~~~
  
    <img src="/Users/seongjayong/Learning/book-spring-reactive/image/그림 3.3 푸시 방식의 처리 흐름 예.png" alt="그림 3.3 푸시 방식의 처리 흐름 예" style="zoom:30%;" />
  
  - 서비스 전체 대기 기간은 짧지만, DB는 필요한 수의 원소를 처리한 이후에도 서비스에서 사용하지 않을 항목을 여전히 생성할 수도 있음.

### 흐름 제어

#### 느린 프로듀서와 빠른 컨슈머

- 컨슈머가 매우 빠르게 동작하는 상황에서 프로듀서가 느리게 동작한다고 가정
- 실제적으로 요구할 수 밖에 없음.. 프로듀서 수의 증대와 같은

#### 빠른 프로듀서와 느린 컨슈머

- 직관적인 솔루션 -> 처리되지 않은 원소를 큐에 수집
- 적절한 특성을 가진 큐를 선택해야 하며 일반적으로 세 가지 유형이 있다.
- 무제한 큐 : 큐의 사이즈 제한 x, 메시지 전달에 확신할 수 있음, 메모리 한도에 도달하면 전체 시스템이 손상될 수 있음
- 크기가 제한된 드롭 큐 : 큐가 가득 차면 신규 유입된 메시지를 무시하는 형태의 큐, 메시지의 중요성이 낮을 때 일반적으로 사용
- 크기가 제한된 블로킹 큐 : 제한에 도달하면 메시지 유입 차단, 시스템의 비동기 동작을 모두 무효화, 리액티브 프로그래밍을 위해선 받아들일 수 없는 시나리오..
- 큐가 있으면 시스템의 전체적인 설계가 복잡해질 수 있으며 결합된 솔루션 간의 균형을 찾는 추가적인 고려 사항이 발생함
- 이런 순수한 푸시 모델..을 위해서 리액티브는 Back Pressure 기능을 넣음

### 리액티브 스트림의 기본 스펙

- 리액티브 스트림 스펙에는 4가지 기본 인터페이스가 있으며 다음과 같다.

  - **Publisher**
  - **Subscriber**
  - **Subscription**
  - **Processor**

- org.reactivestreams 패키지 내에 모든 인터페이스를 포함하는 독립적인 JAR 파일로 사용 가능

- Publisher, Subscriber는 RxJava에 Observable-Observer와 유사함.

  ~~~java
  public interface Publisher<T> {
    void subscribe(Subscriber<? super T> s);
  }
  
  public interface Subscriber<T> {
    void onSubscribe(Subscription s); // RxJava에는 없던 친구, Subscriber에게 구독이 성공했음을 알림.
    void onNext(T t);
    void onError(Throwable t);
    void onComplete();
  }
  ~~~

- Subscription은 원소 생성을 제어하기 위해 기본적인 사항을 제공함.

~~~java
public interface Subscription {
  void request(long n); // Publisher가 보내줘야 하는 데이터 크기를 알려줌 -> 유입 원소 갯수 초과를 막음
  void cancel(); // stream에서 구독, 발행 취소
}
~~~

<img src="/Users/seongjayong/Learning/book-spring-reactive/image/그림 3.7 배압의 작동 원리.png" alt="그림 3.7 배압의 작동 원리" style="zoom:50%;" />

- 또한 스펙에는 BackPressure를 적절하게 제어할 수 있는 하이브리드 푸시-풀 모델이 포함되어 있음.

~~~java
public Publisher<Item> list(int count) {
  Publisher<Item> source = dbClient.getStreamOfItems();
  TakeFilterOperator<Item> takeFilter = new TakeFilterOperator<>(
  	source, count, item -> isValid(item)
  );
  return takeFilter;
}
~~~

~~~java
public class TakeFilterOperator<T> implements Publisher<T> {
  ...;
  
  public void subscribe(Subscriber s) {
    source.subscribe(new TakeFilterInner<>(s, take, predicate));
  }
  
  //실제 Subscriber로서 메인 소스에 전달되는 역할을 한다
  static final class TakeFilterInner<T> implements Subscriber<T>, Subscription {
    final Subscriber<T> actual;
    final int take;
    final Predicate<T> predicate;
    final Queue<T> queue;
    
    Subscription current;
    int remaining;
    int filtered;
    volatile long requested;
    ...
    
    TakeFilterInner(Subscriber<T> actual, int take, Predicate<T> predicate) {
      ...
    }
    
    public void onSubscribe(Subscription current) {
      ...
      current.request(take);
      ...
    }
    
    public void onNext(T element) {
      ...
      long r = requested;
      Subscriber<T> a = actual;
      Subscription s = current;
      
      if(remaining > 0) {
        boolean isValid = predicate.test(element);
        boolean isEmpty = queue.isEmpty();
        if (isValid && r > 0 && isEmpty) {
          a.onNext(element);
          remaining--;
          ...
        }
        else if (isValid && (r == 0 || !isEmpty)) {
          queue.offer(element);
          remaining--;
          ...
        }
        else if (!isValid) {
          filtered++;
        }
      }
      else {
        s.cancel();
        onComplete();
      }
      
      if (filtered > 0 && remaining / filtered < 2) {
        s.request(take);
        filtered = 0;
      }
    }
    ...
  }
}
~~~









